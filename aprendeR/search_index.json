[
["index.html", "aprendeR Capítulo 1 Introducción", " aprendeR Andrea Fernández Conde Capítulo 1 Introducción R inicia a principios de los noventas en la Universidad de Auckland en Nueva Zelanda. Ross Ihaka, profesor del departamento de estadística, pensaba que debía existir una alternativa superior para el análisis de datos realizado por los alumnos, que utilizaban lo que él llamaba programas viejos y cuchos. Robert Gentleman le sugiere a Ross escribir un software cuya ambición inicial era poder enseñar sus cursos de licenciatura de primer año. Así, en 1991 generan una estructura básica a través de la cuál sus estudiantes podían hacer análisis de datos y producir modelos gráficos de la información. Lo bautizan R por sus iniciales (Ingenio 2016). Ross y Robert no comercializan el software sino que lo ponen a disposición de otros interesados. Ross ha expresado que R cambió su opinión acerca de la humanidad pues es el resultado del trabajo de muchos que no reciben ingresos o reconocimiento por el mismo (Ingenio 2016). En 1996, presentan R en un paper introductorio (Ihaka and Gentleman 1996). A partir de entonces, R ha crecido en forma importante. Entre los contribuidores actuales más relevantes se encuentra Hadley Wickham, alumno de licenciatura en el departamento de estadística de la Universidad de Auckland cuando R se encontraba en desarrollo. En la gráfica siguiente, se muestran las descargas anuales de paquetes de R del 2012 al 2016 del espejo de RStudio.1 Figura 1.1: Descargas anuales del espejo de RStudio de paquetes de R de 2012 a 2016 (en millones). En el 2016 paquetes de R fueron descargados 218,480,053 veces. El aumento en la popularidad de R no es el único elemento por el cuál R es un lenguaje valioso. Sin embargo, el que sea un lenguaje comúnmente enseñado en universidades y utilizado en empresas, lo convierte en una habilidad con considerable valor de mercado. En la encuesta de Stackoverflow, R se encuentra en el lugar séptimo de los mejores pagados para los desarrolladores cuya ocupación es matemáticas, superando a Python y a SQL (Stackoverflow 2016, Top paying tech per occupation, mathematics). En cuanto a las tecnologías más populares por tipo de desarrollador que declara dedicarse a matemáticas y datos, R está en el sexto lugar, el primer lugar lo tiene python, seguido de SQL (Stackoverflow 2016, Most Popular Technologies per Dev Type, Math and Data). Actualmente, R, python y SQL se encuentran entre las herramientas más populares tanto entre desarrolladores como empresas, aunque no son las únicas. La decisión de aprender alguno de estos lenguajes depende de muchos factores, entre ellos cuán natural resulta la interacción individual con cada cuál, el lenguaje preferido en el grupo de trabajo particular y el tipo de análisis que se requiere realizar en el día a día. Escapa del objetivo de este manual el realizar una comparación exhaustiva de tecnologías pero se recomienda tener en cuenta que cada herramienta tiene una especialidad específica y, particularmente en un ambiente de producción, es necesario tener esto en consideración. R es un excelente lenguaje para aprender ciencia de datos; de hecho en CRAN (2016) se describe a R como un proyecto para estadística computacional. Esto lo convierte en un lenguaje único pues fue construido por estadísticos y diseñado para realizar análisis de datos. Su uso generalizado en la comunidad estadística tiene la ventaja de que casi cualquier prueba o técnica estadística puede ser encontrada en algún paquete de R (Labs 2016). Además, existe una documentación extensa y estandarizada que facilita su uso. Aunque el material para aprender R es amplio y hay una comunidad mundial muy activa que constantemente produce nuevos recursos, existen pocas referencias que faciliten iniciar su aprendizaje para hispanoparlantes. En general, la documentación, listas de distribución, libros y tutoriales están escritos en inglés. Este manual tiene como objetivo guiar a principiantes en programación que tienen una formación previa como analistas de datos. El enfoque principal es el de facilitar de ejemplos que permitan al analista traducir la manipulación de datos que ya saben realizar en otro ambiente a R. El manual se estructura como sigue: en el capítulo 2 , se introducen elementos básicos para poder iniciar el trabajo en R. Se especifica cómo instalar el software, se recomienda utilizar un editor especializado, así como paquetes útiles para diferentes tareas. En particular, se explica cómo guardar código de manera que otras personas puedan ejecutarlo y cómo realizar documentos reproducibles. Por último, se explica cómo accesar a la ayuda y documentación, así como la forma en la que puede optimizarse su funcionamiento. Este capítulo actúa más como una referencia general para poder realizar el trabajo en el ambiente. En el capítulo 3, se introducen las funciones, las estructuras de datos y las estructuras de control disponibles en el lenguaje. El capítulo 4, explica como operar los objetos y estructuras detallados en el capítulo anterior, proporcionando múltiples ejemplos y ejercicios para familiarizar al lector con el lenguaje. El capítulo 5, detalla las herramientas básicas para poder realizar un proyecto de datos en R. Las herramientas que se desarrollan en este capítulo permiten iterar sobre parte del ciclo de un proyecto de datos: importación de datos al ambiente, manipulación, limpieza y visualización de los mismos. Éstas herramientas permiten operar sobre los objetos introducidos en el capítulo 3 en una forma eficiente, fácil de aprender, fácil de leer y que permite que el usuario realice manipulaciones de datos complejas que le permitirán, a su vez, utilizar todas las herramientas de modelado que R posee que necesitan como insumo datos limpios y preparados en una forma específica. Cada capítulo incluye ejercicios y respuestas a los mismos; al final se recomienda material adicional para repasar los conceptos estudiados. El material se encuentra disponible electrónicamente en https://github.com/animalito/aprendeR. Para facilitar el aprendizaje, se recomienda descargar los materiales o clonar el repositorio, esto permite revisar el material y el código desde el ambiente local evitando copiar y pegar el mismo para su ejecución. Bibliografía "],
["r-lo-basico.html", "Capítulo 2 R: lo básico", " Capítulo 2 R: lo básico En este capítulo se revisarán elementos básicos para poder iniciar el trabajo en R. Primero que nada, se proporcionan instrucciones de instalación según el sistema operativo utilizado. Posteriormente, se recomiendan editores que facilitan la edición de código y documentos en R, particularmente Rstudio o Emacs combinado con ESS. Posteriormente, se describe brevemente el espacio de trabajo y se dan algunos ejemplos que ilustran la interacción con la consola. Se cubren algunos temas útiles para el trabajo continuo en R: se recomiendan paquetes que complementan a la instalación básica de R y que son particularmente útiles para el análisis de datos; se describe qué es un script y un documento de R; se explica cómo obtener ayuda y accesar a la documentación. Por último, se recomienda realizar instalaciones adicionales que permiten optimizar el trabajo de álgebra lineal que soporta los distintos métodos implementados en R. "],
["instalacion.html", "2.1 Instalación", " 2.1 Instalación Para los usuarios de Linux, se pueden correr los siguientes comandos en la consola para instalar R compilándolo (Escalante 2015). Ésta es la mejor opción pues se aprovecharán todas las características de su máquina. #!/bin/bash while true; do read -p &quot;Do you wish to Compile R? y/n &quot; yn case $yn in [Yy]* ) sudo apt-get update; sudo apt-get upgrade -y; sudo apt-get install -y build-essential libpq-dev liblapack3 libblas3 \\ libmysql++-dev sqlite3 fort77 gnuplot-x11 texinfo liblapack-dev \\ texi2html libglpk-dev libgeos-dev libgdal1-dev libproj-dev; sudo apt install -y gfortran autoconf automake bzip2-doc cdbs \\ debhelper dh-strip-nondeterminism dh-translations gettext intltool \\ intltool-debian libarchive-zip-perl libasprintf-dev libbz2-dev \\ libfile-stripnondeterminism-perl libgettextpo-dev libgettextpo0 \\ liblzma-dev libmail-sendmail-perl libncurses5-dev libpcre3-dev \\ libpcre32-3 libpcrecpp0v5 libreadline-dev libreadline6-dev \\ libsys-hostname-long-perl libtinfo-dev libunistring0 m4 po-debconf \\ python-scour xorg-dev libcairo2-dev libgtk2.0-dev; sudo apt-get -y build-dep r-base; mkdir -p $HOME/src; cd $HOME/src; wget -c http://cran.r-project.org/src/base/R-latest.tar.gz; tar zxvf R-latest.tar.gz &amp;&amp; rm R-latest.tar.gz; cd &quot;$(ls -dt R-*/ | head -1 )&quot;; ./configure --enable-memory-profiling --enable-R-shlib \\ --with-blas --with-lapack --with-tcltk --with-cairo \\ --with-libpng --with-jpeglib --with-libtiff; make; sudo make install; break;; [Nn]* ) sudo apt-key adv --keyserver keyserver.ubuntu.com \\ --recv-keys E084DAB9; ubuntu_codename=`lsb_release -cs` ; sudo chmod ugo+rw /etc/apt/sources.list; echo \\ &quot;deb http://cran.r-project.org/bin/linux/ubuntu $ubuntu_codename/&quot; \\ &gt;&gt; &#39;/etc/apt/sources.list&#39;; sudo apt-get update; sudo apt-get install -y --no-install-recommends r-base r-base-dev; exit;; * ) echo &quot;Please answer yes or no.&quot;;; esac done Para descargar e instalar R en su versión precompilada, seguir las instrucciones de este link para el sistema operativo que estén utilizando. Bibliografía "],
["editores.html", "2.2 Editores", " 2.2 Editores Hay muchísimos, en particular se mencionarán dos. 2.2.1 RStudio Puedes descargar RStudio siguiendo las instrucciones para cada sistema operativo. RStudio es un IDE (integrated development environment) para R que incluye consola, editor de texto, memoria de gráficos, vista de objetos en el ambiente y otras herramientas útiles para desarrollar (RStudio Team 2016). En su versión más reciente, también autocompleta código y depura (debugging) “al vuelo”, es decir, al mismo tiempo que se escribe, señala potenciales errores de código. Hay que tener cuidad con el uso de la memoria RAM de este editor pues utiliza muchos recursos de la computadora y -cuando están usando una gran cantidad de datos o procesos muy pesados- RStudio suele detenerse fácilmente. Buenas prácticas en general: guardar seguido, seguir un flujo de trabajo (workflow) aunado a controlador de versiones (o algún tipo de respaldo) y, sobretodo, crear las funciones, lógica, algoritmos, con una muestra de los datos. 2.2.2 ESS Emacs speaks statistics es el add-on favorito para los usuarios de emacs y R (Rossini et al. 2004). Soporta la edición de scripts para R, S-plus, SAS, Stata, OPenBUGS/JAGS. Para los que además ya están acostumbrados al enorme poder de Emacs, ésta será la mejor opción. El editor interactivo es muy bueno y casi no consume memoria. Bibliografía "],
["el-espacio-de-trabajo-workspace.html", "2.3 El espacio de trabajo (Workspace)", " 2.3 El espacio de trabajo (Workspace) El espacio de trabajo es el ambiente actual de trabajo en R. Incluye todos los objetos definidos por el usuario (vectores, matrices, funciones, dataframes, listas). Una sesión de R inicia cuando abres la consola. Al terminar el trabajo se puede guardar la imagen del espacio de trabajo tal cual está, de manera que sea posible continuar desde donde te quedaste (Kabacoff 2015, pág. 11). 2.3.1 Directorio de trabajo El directorio de trabajo (working directory) es el directorio en tu computadora en el que estás trabajando en ese momento. Cuando se le pide a R que abra un archivo o guarde ciertos datos, R lo hará a partir del directorio de trabajo que le hayas fijado. Para saber en qué directorio te encuentras, se usa el comando getwd(). Usa la mnemotécnica del inglés: get working directory ≡ getwd. Notarás como muchas funciones tienen un nombre que acorta lo que hacen. getwd() ## [1] &quot;/home/salim/SOCIEDAT/ssR&quot; Para especificar el directorio de trabajo, se utiliza el comando setwd() (set working directory) en la consola. Y volvemos a setwd(&quot;/home/animalito/study/&quot;) getwd() Ejercicios Abre tu consola de R y escribe setwd(). Utiliza la tecla tab para autocompletar las posibles rutas desde donde quiera que estés. Escoge alguna (nuevamente usando la tecla tab para moverte entre las opciones). Si esto no funciona, teclea textualmente alguna de las rutas que ves. Cierra la doble comilla y el paréntesis. Teclea enter. Debes encontrarte en la ruta elegida cuando tecleas getwd(). Con lo que acabamos de hacer, R buscará archivos o guardará archivos en la carpeta que obtuviste con el comando getwd(). En R también es posible navegar a partir de el directorio de trabajo. Como siempre, ../un_archivo.R le indica a R que busque una carpeta arriba del actual directorio de trabajo por el archivo un_archivo.R. datos/otro_archivo.R hace que se busque en el directorio de trabajo, dentro de la carpeta datos por el archivo otro_archivo.R Rutas relativas vs. Rutas absolutas El resultado que se muestra aquí al usar el comando getwd() depende de la computadora en la que se esta trabajando debido a que es una ruta absoluta. Nota como es diferente la ruta que obtienes al correr el comando en tu consola de R. Eso es porque se trata de una ruta absoluta, es decir, es tal que da la ruta (path) completo al directorio en cuestión. Puedes accesar todos los directorios o archivos usando su ruta absoluta. En investigación reproducible (reproducible research), en investigación colaborativa o incluso cuando trabajas en varias computadoras es una buena idea usar rutas relativas en lugar de absolutas. Esto hace que el código sea menos dependiente de una estructura de archivos o computadora en particular (Gandrud 2013, pág. 67). En general, es buena práctica configurar el código de un proyecto con rutas relativas. En R en particular, cuando guardas un Rmarkdown y lo corres desde la línea de comandos (o lo tejes desde RStudio), la ruta que está fija -como si hubieras usado el comando setwd() es en donde vive ese archivo, es decir, el directorio en donde está guardado el mismo. Desde cualquier script puedes llamar a otros usando este tipo de ruta como en el ejemplo anterior. 2.3.2 Ejemplos básicos La consola permite hacer operaciones sobre números o caracteres (cuando tiene sentido). # Potencias, sumas, multiplicaciones 2^3 + 67 * 4 - (45 + 5) ## [1] 226 # Comparaciones 56 &gt; 78 ## [1] FALSE 34 &lt;= 34 ## [1] TRUE 234 &lt; 345 ## [1] TRUE &quot;hola&quot; == &quot;hola&quot; ## [1] TRUE &quot;buu&quot; != &quot;yay&quot; ## [1] TRUE # módulo 10 %% 4 ## [1] 2 Estas operaciones también pueden ser realizadas entre vectores2. # Creamos un vector con entradas del -1 al 12 y lo asignamos a la variable x x &lt;- -1:12 # Lo vemos x ## [1] -1 0 1 2 3 4 5 6 7 8 9 10 11 12 # Le sumamos 1 a todas las entradas x + 1 ## [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 # Multiplicamos por 2 cada entrada y le sumamos 3 2 * x + 3 ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 # Sacamos el módulo de cada entrada x %% 5 ## [1] 4 0 1 2 3 4 0 1 2 3 4 0 1 2 2.3.3 Comandos útiles Para enlistar los objetos que están en el espacio de trabajo ls() ## [1] &quot;aprueba&quot; &quot;busca&quot; &quot;calificaciones&quot; &quot;df&quot; ## [5] &quot;df2&quot; &quot;group.colors&quot; &quot;id&quot; &quot;l&quot; ## [9] &quot;l1&quot; &quot;l2&quot; &quot;letras&quot; &quot;lista&quot; ## [13] &quot;m&quot; &quot;medias&quot; &quot;res&quot; &quot;x&quot; Para eliminar todos los objetos en un directorio de trabajo (workspace) rm(list = ls()) # se puede borrar solo uno, por ejemplo, nombrándolo ls() ## character(0) También se puede utilizar/guardar la historia de comandos utilizados history() history(max.show = 5) history(max.show = Inf) # Muestra toda la historia # Se puede salvar la historia de comandos a un archivo savehistory(file = &quot;mihistoria&quot;) # Por default, R ya hace esto # en un archivo &quot;.Rhistory&quot; # Cargar al espacio de trabajo actual (current workspace) una # historia de comandos en particular loadhistory(file = &quot;mihistoria&quot;) Es posible también guardar el ambiente de trabao (workspace) -en forma completa- en un archivo con el comando save.image() a un archivo con extensión .RData. Puedes guardar una lista de objetos específica a un archivo .RData. Por ejemplo: x &lt;- 1:12 y &lt;- 3:45 save(x, y, file = &quot;ejemplo.RData&quot;) #la extensión puede ser arbitraria. Después puedo cargar ese archivo. Prueba hacer: rm(list = ls()) # limpiamos workspace load(file = &quot;ejemplo.RData&quot;) #la extensión puede ser arbitraria. ls() Nota como los objetos preservan el nombre con el que fueron guardados. Bibliografía "],
["paquetes-libraries.html", "2.4 Paquetes (libraries)", " 2.4 Paquetes (libraries) R puede hacer muchos análisis estadísticos y de datos. Las diferentes capacidades están organizadas en paquetes o librerías. Con la instalación estándar resumida en la sección B-2, se instalan también los paquetes más comunes (también llamado el base o R-básico). Para obtener una lista de todos los paquetes instalados se puede utilizar el comando library() en la consola o en un script. Existen una gran cantidad de paquetes disponibles además de los incluidos por omisión (default). 2.4.1 CRAN Comprehensive R Archive Network (CRAN 2016) es una colección de sitios que contienen exactamente el mismo material, es decir, son espejos (mirrors) de las distribuciones de R, las extensiones, la documentación y los binarios. El master de CRAN está en Wirtschaftsuniversität Wien en Austria. Éste se “espeja” (mirrors) en forma diaria a muchos sitios alrededor del mundo. En la lista de espejos se puede ver que para México están disponibles el espejo del ITAM, del Colegio de Postgraduados (Texcoco) y Jellyfish Foundation (CRAN 2016). Los espejos son importantes pues, cada vez que busquen instalar paquetes, se les preguntará qué espejo quieren utilizar para la sesión en cuestión. Del espejo que selecciones, será del cuál R bajará el binario y la documentación. Del CRAN es que se obtiene la última versión oficial de R. Diario se actualizan los espejos. Para más detalles consultar el FAQ. Para contribuir un paquete en CRAN se deben seguir las instrucciones aquí. 2.4.2 Github Git es un controlador de versiones muy popular para desarrollar software. Cuando se combina con GitHub se puede compartir el código con el resto de la comunidad. Éste controlador de versiones es el más popular entre los que contribuyen a R. Muchos problemas a los que uno se enfrenta alguien ya los desarrolló y no necesariamente publicó el paquete en CRAN. Para instalar algún paquete desde GitHub, se pueden seguir las instrucciones siguientes install.packages(&quot;devtools&quot;) devtools::install_github(&quot;username/packagename&quot;) Donde username es el usuario de Github y packagename es el nombre del repositorio que contiene el paquete. Cuidado, no todo repositorio en GitHub es un paquete. Para más información ver el capítulo Git and GitHub en Wickham (2015). 2.4.3 Otras fuentes Otros lugares en donde es común que se publiquen paquetes es en Bioconductor un proyecto de software para la comprensión de datos del genoma humano. Bibliografía "],
["paquetes-recomendados.html", "2.5 Paquetes recomendados", " 2.5 Paquetes recomendados Hay muchísimas librerías y lo recomendable es, dado un problema y un modelo para resolverlo, revisar si alguien ya implementó el método en algunas de las fuentes de paquetes mencionadas antes. Para mantener orden en los paquetes descargados puede ser útil utilizar el Rinker and Kurkiewicz (2015) pues provee de herramientas para instalar paquetes en una forma un poco más sencilla que usando la función install.packages. En particular, la función p_load permite instalar, cargar y actualizar uno o varios paquetes. Si queremos instalar varios paquetes usando las herramientas del R básico (base) (R Core Team 2016b) haríamos algo como (ejemplo tomado de Rinker and Kurkiewicz 2015, en la viñeta de introducción al paquete): packs &lt;- c(&quot;XML&quot;, &quot;devtools&quot;, &quot;RCurl&quot;, &quot;fakePackage&quot;, &quot;SPSSemulate&quot;) success &lt;- suppressWarnings(sapply(packs, require, character.only = TRUE)) install.packages(names(success)[!success]) sapply(names(success)[!success], require, character.only = TRUE) Con pacman::p_load la tarea se reduce a: pacman::p_load(XML, devtools, RCurl, fakePackage, SPSSemulate) Nota como se puede llamar a una función por su nombre p_load una vez que ya cargamos el paquete en el cuál esa función está guardada con el comando library(pacman) o podemos llamarla directamente utilizando la convención paquete::funcion, en este caso, pacman::p_load. Para instalar pacman escribe: install.packages(&quot;pacman&quot;) Algunos paquetes se encuentran en desarrollo. En particular, si se encuentran en github pueden descargarse usando la función pacman::p_install_gh('usuario/repositorio'). A continuación, hay una lista de paquetes que se recomienda descargar o revisar para tener a la mano herramientas diversas útiles para el trabajo del científico de datos. La lista no es comprensiva pues hay un gran número de paquetes útiles. # Para cargar datos al ambiente de trabajo (data load) pacman::p_load(RODBC, RMySQL, RPostgreSQL, RSQLite, foreign, Rpostgres, haven , readr) pacman::p_install_gh(&quot;hadley/readxl&quot;) pacman::p_install_gh(&quot;rstats-db/RPostgres&quot;) # Para manipular datos (data manipulation) pacman::p_load(plyr, dplyr, data.table, tidyr, stringr, lubridate, gsubfn) # Para visualizar datos (data visualization) pacman::p_load(ggplot2, graphics, ggvis) pacman::p_install_gh(&quot;RcppCore/Rcpp&quot;) pacman::p_install_gh(&quot;rstats-db/DBI&quot;) pacman::p_install_gh(&#39;ramnathv/htmlwidgets&#39;) pacman::p_install_gh(&#39;rstudio/leaflet&#39;) pacman::p_install_gh(&#39;bwlewis/rthreejs&#39;) pacman::p_install_gh(&#39;htmlwidgets/sparkline&#39;) pacman::p_load(dygraphs, DT, DiagrammeR, networkD3, googleVis) # Para modelar (data modelling) pacman::p_load(car, mgcv, lme4, nlme, randomForest, multcomp, vcd , glmnet, survival, caret) # Para generar reportes (reports) pacman::p_load(shiny, xtable, knitr, rmarkdown) # Para trabajar con datos espaciales (spatial data) pacman::p_load(sp, maptools, maps, ggmap, rgdal) # Para trabajo con series de tiempo (time series) pacman::p_load(zoo, quantmod) # Para escribir código de alto rendimiento en R (High performance R code) pacman::p_load(Rcpp, parallel) # Trabajar con la web pacman::p_load(XML, jsonlite, httr) # Para escribir paquetes en R pacman::p_load(devtools, testthat, roxygen2) Packrat Cuando cambian las versiones de distintos paquetes de R, es posible que código que solía funcionar deje de hacerlo. Por esta razón, es conveniente empaquetar proyectos de código de manera que el código en un proyecto específico tenga asociados también las versiones específicas de los paquetes con los cuáles fue creado. Una forma de lograr esto es utilizando packrat. Para mayor detalle, ver el apéndice B. Bibliografía "],
["scripting.html", "2.6 Scripting", " 2.6 Scripting R es un intérprete. Utiliza un ambiente basado en línea de comandos. Por ende, es necesario escribir la secuencia de comandos que se desea realizar a diferencia de otras herramientas en donde es posible utilizar el mouse o menús. Aunque los comandos pueden ser ejecutados directamente en consola una única vez, también es posible guardarlos en archivos conocidos como scripts. Típicamente, utilizamos la extensión .R o .r. En RStudio (RStudio Team 2016), CTRL + SHIFT + N abre inmediatamente un nuevo editor en el panel superior izquierdo. En RStudio, por ejemplo, se puede ir editando el script y corriendo los comandos línea por línea con CTRL + ENTER. Esto también aplica para correr una selección del texto editable3. Es posible también ejecutar todo el script source(&quot;foo.R&quot;) O con el atajo CTRL + SHIFT + S en RStudio. Para enlistar algunos atajos (shortcuts) comunes en RStudio presiona ALT + SHIFT + K. De la misma manera, si utilizas Emacs + ESS (Rossini et al. 2004), existen múltiples atajos de teclado para realizar todo mucho más eficientemente. Estudiarlos no es tiempo perdido. Bibliografía "],
["rmarkdown.html", "2.7 rmarkdown", " 2.7 rmarkdown Es posible generar documentos reproducibles en R utilizando R Markdown, un framework que permite salvar y ejecutar código, así como generar reportes de alta calidad en múltiples formatos (Inc. 2016b). Para utilizarlo, se instala el paquete rmarkdown con el comando: install.packages(&quot;rmarkdown&quot;) Para generar un documento, se necesitan conocer únicamente algunos elementos importantes. La extensión que se suele utilizar para estos documentos es .Rmd o .rmd. 2.7.1 Encabezado y formatos El primer elemento es el encabezado y se conoce como el yaml o front-matter. Se coloca en la parte superior del documento y corresponde a las opciones que ofrece pandoc para la generación de documentos. Éste contiene la especificación de elementos como el título del documento, autor, fecha, entre otros. Además, se especifica el formato de salida del documento. Para crear un documento en HTML, por ejemplo, es necesario especificar como el output del documento html_output y se ve como sigue: --- title: &quot;Un título&quot; author: &quot;Un autor&quot; date: &quot;Una fecha&quot; output: html_document: toc: yes toc_depth: 2 toc_float: true theme: spacelab --- En este ejemplo, se colocaron opciones adicionales para el documento HTML como el que incluya una tabla de contenidos (toc: yes), que la profundidad de dicha tabla de contenidos incluya los primeros dos niveles de encabezados (toc_depth: 2), que la tabla de contenidos sea flotante -que se encuentre fija en una barra a la izquierda del documento aunque se desplace el documento (toc_float: true) y, por último, se especifica el tema para la estética del documento (theme: spacelab). Existen muchas otras opciones, mismas que puedes encontrar en la documentación (Inc. 2016a). Es posible también especificar como salida para el documento un pdf con la opción pdf_document. Las opciones se encuentran también en la documentación (Inc. 2016c). Esta opción es conveniente cuando se tiene conocimiento previo de LaTeX. Por último, cabe mencionar la opción word_document, cuyas opciones se encuentran aquí (Inc. 2016e) y la opción md_document que compila a Markdown. Así como es posible generar documentos, es posible crear presentaciones en HTML (ioslides o slidy) o pdf (beamer) (Inc. 2016d) y dashboards (con flexdashboards) (Allaire 2016). En el apéndice A se detalla la sintaxis de Markdown, misma que permitirá escribir documentos. 2.7.2 Knitr chunks Entre distintas líneas de texto, es posible incluir chunks o pedazos de código de R. Para iniciar un pedazo de código, se incluyen tres acentos invertidos, seguidos de la letra r entre llaves; se cierra un pedazo de código con tres acentos invertidos (Inc. 2016d). ```{r} paste(&quot;Hola&quot;, &quot;Mundo&quot;) ``` ## [1] &quot;Hola Mundo&quot; Se puede incluir un pedazo de código en cualquier parte del documento y se controlan las opciones de cada pedazo, por ejemplo, incluyendo una opción para que el código no se imprima y que solo se imprima el resultado agregando {r, echo = FALSE}: ## [1] &quot;Hola Mundo&quot; Las opciones se encuentran resumidas en Inc. (2016d). Bibliografía "],
["ayuda-y-documentacion.html", "2.8 Ayuda y documentación", " 2.8 Ayuda y documentación R tiene mucha documentación. Dado que es imposible recordar todas las funciones o cómo utilizar todo lo que ya está hecho, es necesario aprender a leerla. Desde la consola se puede accesar a la misma. Para ayuda general, help.start() Para la ayuda de una función en especifico, por ejemplo, si se quiere graficar algo y sabemos que existe la función plot podemos consultar fácilmente la ayuda. help(plot) # o tecleando directamente ?plot El segundo ejemplo se puede extender para buscar esa función en todos los paquetes que tengo instalados en mi ambiente al escribir ??plot. A veces, es útil ver el cuerpo de una función. Esta tarea no necesariamente es trivial. Para funciones generadas por el usuario, usa xx &lt;- function(x) x^2 body(xx) ## x^2 # o simplemente imprimir el objeto en donde guardamos la función xx ## function(x) x^2 También funciona para algunas funciones de paquete, por ejemplo rename: library(plyr) body(rename) ## { ## names(x) &lt;- revalue(names(x), replace, warn_missing = warn_missing) ## duplicated_names &lt;- names(x)[duplicated(names(x))] ## if (warn_duplicated &amp;&amp; (length(duplicated_names) &gt; 0L)) { ## duplicated_names_message &lt;- paste0(&quot;`&quot;, duplicated_names, ## &quot;`&quot;, collapse = &quot;, &quot;) ## warning(&quot;The plyr::rename operation has created duplicates for the &quot;, ## &quot;following name(s): (&quot;, duplicated_names_message, ## &quot;)&quot;, call. = FALSE) ## } ## x ## } Para plot, en cambio, al usar la función body se ve: body(plot) ## UseMethod(&quot;plot&quot;) Esto es porque plot es una función genérica (S3) que tiene métodos para distintas clases de objetos. En esos casos, primero debemos usar la función methods para enlistar los métodos que tiene esa función. methods(plot) ## [1] plot.acf* plot,ANY-method plot,color-method ## [4] plot.data.frame* plot.decomposed.ts* plot.default ## [7] plot.dendrogram* plot.density* plot.ecdf ## [10] plot.factor* plot.formula* plot.function ## [13] plot.ggplot* plot.gtable* plot.hclust* ## [16] plot.histogram* plot.HoltWinters* plot.isoreg* ## [19] plot.lm* plot.medpolish* plot.mlm* ## [22] plot.ppr* plot.prcomp* plot.princomp* ## [25] plot.profile.nls* plot.R6* plot.raster* ## [28] plot.spec* plot.stepfun plot.stl* ## [31] plot.table* plot.ts plot.tskernel* ## [34] plot.TukeyHSD* ## see &#39;?methods&#39; for accessing help and source code Si tiene asteriscos, significa que la función para ese método en particular no viene directamente del espacio de nombres del paquete pero, de cualquier forma, lo podemos pedir usando la función getAnywhere para cualquiera de los métodos que se desplegaron: getAnywhere(plot.density) ## A single object matching &#39;plot.density&#39; was found ## It was found in the following places ## registered S3 method for plot from namespace stats ## namespace:stats ## with value ## ## function (x, main = NULL, xlab = NULL, ylab = &quot;Density&quot;, type = &quot;l&quot;, ## zero.line = TRUE, ...) ## { ## if (is.null(xlab)) ## xlab &lt;- paste(&quot;N =&quot;, x$n, &quot; Bandwidth =&quot;, formatC(x$bw)) ## if (is.null(main)) ## main &lt;- deparse(x$call) ## plot.default(x, main = main, xlab = xlab, ylab = ylab, type = type, ## ...) ## if (zero.line) ## abline(h = 0, lwd = 0.1, col = &quot;gray&quot;) ## invisible(NULL) ## } ## &lt;bytecode: 0x5956750&gt; ## &lt;environment: namespace:stats&gt; Nota como el método plot.density viene del paquete stats.4 La documentación normalmente se acompaña de ejemplos. Para correr los ejemplos sin necesidad de copiar y pegar, prueba example(plot) Para búsquedas más comprensivas, se puede buscar de otras maneras: apropos(&quot;foo&quot;) # Enlista todas las funciones que contengan la cadena &quot;foo&quot; RSiteSearch(&quot;foo&quot;) # Busca por la cadena &quot;foo&quot; en todos # los manuales de ayuda y listas de distribución. Hay otro tipo de funciones en las que accesar al código fuente no se pueda con los métodos descritos. Para ello, es útil revisar la sección “old-school object-oriented programming in R” (Adler 2010, págs. 131-133) o las secciones dedicadas a los objetos S3 y S4 en Wickham (2014).↩ "],
["optimizando.html", "2.9 Optimizando", " 2.9 Optimizando Es común que muy pronto nos encontremos con limitaciones al poder de cómputo y rapidez con el que R procesa los datos. Hay operaciones intensivas como, por ejemplo, la inversión de matrices (qr) o el análisis por componentes principales (svd). Incluso una selección de variables (back/forward selection) usando una simple regresión lineal sobre múltiples regresores puede llevar un tiempo de cómputo de horas/días o no terminar. Una de las manera más rápidas de mejorar el rendimiento (performance) de R es instalando las librerías de álgebra lineal que puede utilizar el software para hacer las operaciones más rápido. Para mucho (demasiado) detalle al respecto, referirse a la comparación de rendimiento en Eddelbuettel (2010) o al paquete del mismo autor Eddelbuettel (2016). Para la parte práctica de todo esto, referirse a este blog para instalar las librerías apropiadas para BLAS y Lapack (Klamer 2014). Para una comparación bastante práctica de las diferentes versiones de esas librerías, ver aquí (Nguyen 2014). Bibliografía "],
["material-adicional.html", "2.10 Material adicional", " 2.10 Material adicional Práctica y paciencia son dos elementos fundamentales para tener éxito cuando se aprende un nuevo lenguaje de programación. Un proyecto interesante para aprender R es swirl (Kross et al. 2016), un paquete en CRAN en el que se desarrolla una gama de cursos que permiten aprender interactivamente desde la consola de R. El material actualmente se encuentra en inglés. Para instalar swirl, install.packages(&quot;swirl&quot;) library(&quot;swirl&quot;) Luego llama a la función swirl para activarlo swirl() Lo primero que te pedirá es un nombre de usuario (para que pueda guardar el avance en los cursos y no debas regresar) y dará algunas instrucciones y comandos útiles. skip() para saltarte la pregunta actual play() para poder utilizar la consola en ese momento y practicar un poco más nxt() para que se pase a la siguiente pregunta bye() para salir de swirl main() para regresar al menú principal info() para recordar las instrucciones Una vez que te da la introducción, acepta que te instale el curso de R Programming El material de este capítulo se cubre en los módulos 1 a 3 del curso R Programming. Bibliografía "],
["estructuras-y-funciones.html", "Capítulo 3 Estructuras y funciones", " Capítulo 3 Estructuras y funciones En este capítulo se introducen los principales objetos de R. Primero, se definen brevemente. Después se introducen las funciones, objetos que permiten realizar acciones sobre otros objetos. Posteriormente, se introducen las distintas estructuras de datos en R básico. El primer bloque de construcción son las clases de datos con los que R sabe trabajar, es decir, caracteres, números enteros, reales, complejos y booleanos. El segundo bloque son los vectores. Esta es una estructura fundamental en R y están conformados por un conjunto de elementos de una de las clases de datos. El tercero son las matrices, que le agregan una dimensión a los vectores. Las listas son como vectores pero pueden contener un subconjunto de elementos de cualesquiera de las clases, incluida otra lista. Los dataframes son listas con la restricción que cada uno de sus elementos es un vector del mismo tamaño. Esta estructura es la más natural para un estadístico pues refiere a la forma tabular en la que se acostumbra pensar a los datos en esa disciplina. Los tibbles y los datatables extienden los dataframes, haciéndolos más eficientes para el procesamiento de una mayor cantidad de datos. Finalmente, se mencionan objetos adicionales -como el infinito y el objeto que representa valores perdidos- y se describen las principales estructuras de control, proporcionando ejemplos para escribirlos en R. "],
["objetos.html", "3.1 Objetos", " 3.1 Objetos En R Todo lo que existe es un objeto. Todo lo que sucede es una llamada a una función. Todo lenguaje de programación provee de una forma de accesar los datos guardados en memoria. R no permite un acceso directo a la memoria de la computadora pero ofrece varias estructuras de datos especializadas para realizar esa tarea. A estas estructuras, se les da el nombre de objetos (R Core Team 2016a, ver sección 2 “objetos”). Estos objetos son referidos a través de símbolos o variables, sin embargo, los símbolos son también objetos y pueden ser manipulados de la misma manera. Todos los objetos tienen un tipo, mismo que se le puede preguntar a los objetos con la función typeof typeof(&quot;hola&quot;) ## [1] &quot;character&quot; Esta función puede reconocer muchos tipos, entre ellos algunos de los que veremos con mayor detalle a continuación. Comenzaremos con las funciones que, regresando al cuadro anterior, todo lo que sucede es una llamada a una función. Posteriormente, se revisarán las estructuras de datos más básicas en R y, por último, se verán estructuras de control básicas que permitirán mezclar el uso de objetos de manera que se operen bajo ciertas condiciones lógicas. Bibliografía "],
["funciones.html", "3.2 Funciones", " 3.2 Funciones Hay una regla de oro en programación en general: DRY code5 (acrónimo de “Don’t repeat yourself”) (Hunt and Thomas 1999). Básicamente esto se reduce a no te repitas. Cuando tienes las mismas líneas de código varias veces (cuando estas copiando y pegando mucho) entonces lo que necesitas es escribir una función que realice esa tarea. En R las funciones son los building blocks de básicamente todo. Como todo lo demás en R, las funciones son también objetos. Cuando llamas a un objeto en R, casi siempre estas en realidad llamando a una función. 3.2.1 Componentes de una función El body() o cuerpo de la función es el código dentro de la misma. formals() o el listado de argumentos formales de la función, controla cómo se puede llamar a una función. El ambiente environment() determina cómo son referidas las variables dentro de la función. La lista de argumentos se obtiene con args() # Ejecuto la función f &lt;- function(x) x # Imprimo el objeto f f ## function(x) x # Al usar la función body, veo solo el cuerpo body(f) ## x # Listo sus parámetros o argumentos formals(f) ## $x # Veo en qué ambiente está la función environment(f) ## &lt;environment: R_GlobalEnv&gt; Una vez definida una función, llamarla es muy sencillo: se le proporciona un valor para los parámetros y nos regresa el resultado esperado. Una función puede regresar cualquier objeto, por ejemplo, una función o un valor. Llamamos a la función declarada arriba: f(4) ## [1] 4 # Elimino la función del espacio de trabajo rm(f) Por defecto (default), los argumentos de una función son flojos (lazy), es decir, solamente son evaluados cuando se utilizan (esto es importante pues si tienes un error en una función no te darás cuenta cuando ejecutes la misma sino cuando la mandes llamar). 3.2.2 El ambiente Las variables que se definen dentro de una función existen en un ambiente distinto al ambiente global de R. Si una variable no está definida dentro de la función, R busca en el nivel superior por esa variable. x &lt;- 2 g &lt;- function() { y &lt;- 1 c(x, y) } g() ## [1] 2 1 rm(x, g) Así como fuimos capaces de anidar ciclos for, también podemos anidar funciones. Esta capacidad es muy útil pero hay que tener cuidado con los ambientes y la jerarquía en los mismos. myfuncion &lt;- function() { print(&quot;Hola&quot;) } myfuncion() ## [1] &quot;Hola&quot; Podemos generar funciones con mayor utilidad. suma &lt;- function(x, y){ return(x + y) } vector &lt;- c(1, 2, 3, 4) sapply(vector, suma, 2) ## [1] 3 4 5 6 Toda función regresa un valor. x &lt;- 10 f &lt;- function() { y &lt;- 25 g &lt;- function() { z &lt;- 30 c(x = x, y = y, z = z) } g() } f() ## x y z ## 10 25 30 f &lt;- function(x) { x * 2 } g &lt;- function(x) { x + 2 } f(g(2)) ## [1] 8 g(f(2)) ## [1] 6 En este caso, utilizamos una función con parámetros que recibe cuando es llamada. También podemos generar funciones con valores predefinidos, es decir, defaults. Éstos son utilizados cuando se llama a la función a menos que se especifique lo contrario (es decir, se overide them). f &lt;- function(a = 2, b = 3) { return(a + b) } f() ## [1] 5 f(4, 5) ## [1] 9 f(b = 4) ## [1] 6 Return No es necesario especificar lo que regresa la función. Las funciones por default regresan el último elemento o valor computado. 3.2.3 Reglas de visibilidad (scoping) Sabemos que existe la función c que nos permite concatenar vectores o elementos a vectores. Sin embargo, es posible asignar un valor a una variable llamada c y que la función c siga funcionando. c &lt;- 1000 c + 1 ## [1] 1001 x &lt;- c(1:4) x ## [1] 1 2 3 4 Esto es debido a que R tienen espacios de nombres (namespaces) separados para funciones y no-funciones. Cuando R intenta concatenar los valores del 1 al 4, busca primero en el ambiente global y, en caso de no encontrarlo, busca en los namespaces de cada uno de los paquetes que tiene cargados. El orden en el que busca se puede encontrar utilizando el comando search(). search() ## [1] &quot;.GlobalEnv&quot; &quot;package:xtable&quot; &quot;package:tibble&quot; ## [4] &quot;package:data.table&quot; &quot;package:carData&quot; &quot;package:VIF&quot; ## [7] &quot;package:lubridate&quot; &quot;package:cranlogs&quot; &quot;package:plyr&quot; ## [10] &quot;package:ggplot2&quot; &quot;package:dplyr&quot; &quot;package:knitr&quot; ## [13] &quot;tools:rstudio&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [16] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [19] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; Los paquetes recién llamados acaban en la posición número 2 y todo lo demás se recorre en el orden de la lista. Nota como el base (que se carga por default en toda sesión) está hasta el final. .GlobalEnv es el workspace del que hablamos antes. Si hay un símbolo que corresponde a tu petición entonces tomará el valor en tu workspace para poder ejecutar tu petición. Si no encuentra nada, busca en el namespace de cada uno de los paquetes que has cargado hasta el momento en el orden en el que los llamaste. Esto es muy importante. Hay contribuidores de paquetes en todo el mundo y es muy común que utilicen el mismo nombre para implementaciones de distintas cosas y, por lo tanto, a veces nuestros resultados no son lo que esperábamos. El orden en el que cargamos los paquetes importa: ## &lt;environment: namespace:car&gt; ## &lt;environment: namespace:car&gt; ## &lt;environment: namespace:VIF&gt; La otra opción, sin quitar el paquete del ambiente, es especificar de que paquete tomarlo. En otras palabras, le pedimos explícitamente a R que busque la función en el espacio de nombres de un paquete en específico y que no use su búsqueda normal. environment(VIF::vif) ## &lt;environment: namespace:VIF&gt; environment(car::vif) ## &lt;environment: namespace:car&gt; Bibliografía "],
["estructuras-de-datos.html", "3.3 Estructuras de datos", " 3.3 Estructuras de datos R tiene diferentes tipos y estructuras de datos que permiten al usuario aprovechar el lenguaje. La manipulación de estos objetos es algo que se hace diario y entender cómo operarlos o cómo convertir de una a otra es muy útil. 3.3.1 Clases atómicas (atomic classes) R tiene 6 clases atómicas6 (R Core Team 2016a). character (caracter) numeric (números reales o decimales, a esta clase también se le llama double) integer (números enteros) logical (booleanos, i.e. falso-verdadero) complex (números complejos) raw (contiene bytes) Cuadro 3.1: Clases atómicas Type Tipo Ejemplo character Caracter ‘hola’, ‘x’ numeric Numérico 67, 45.5 integer Integer 2L, 67L logical Lógico TRUE, FALSE, T, F complex Complejo 1+4i raw Crudo 01 - imprime hexadecimales Algunos comandos importantes para las clases atómicas son su tipo typeof(), su tamaño length() y sus atributos attributes(), es decir, sus metadatos. ############ Ejemplo 1 x &lt;- &quot;una cadena&quot; typeof(x) ## [1] &quot;character&quot; length(x) # tamaño: ¿cuántas cadenas son? ## [1] 1 nchar(x) # Número de caracteres ## [1] 10 attributes(x) # Le pusimos metadatos? ## NULL ############ Ejemplo 2 y &lt;- 1:10 typeof(y) ## [1] &quot;integer&quot; length(y) ## [1] 10 attributes(y) ## NULL ############ Ejemplo 3 z &lt;- c(1L, 2L, 3L) # Nota como para denotar enteros se incluye una L al final typeof(z) ## [1] &quot;integer&quot; length(z) ## [1] 3 3.3.2 Vectores Los vectores son la estructura de datos más básica de R (Wickham 2014). Hay dos tipos de vectores: vectores atómicos y listas. Típicamente -en libros, blogs, manuales, cuando se mencionan vectores se refieren a los atómicos y no a las listas. 3.3.2.1 Vectores atómicos Los vectores pueden ser pensados como celdas contiguas que contienen datos (R Core Team 2016a), es decir, elementos de alguna de las clases atómicas (character, logical, integer, numeric). Se puede crear un vector vacío con el comando vector() así como especificar su tamaño y su clase. v &lt;- vector() v ## logical(0) ## Especifico clase y longitud vector(&quot;character&quot;, length = 10) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## Lo mismo pero usando un wrapper character(10) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## Numerico de tamaño 5 numeric(5) ## [1] 0 0 0 0 0 ## Lógico tamaño 5 logical(5) ## [1] FALSE FALSE FALSE FALSE FALSE 3.3.2.2 Tipos de vectores Realiza los siguientes ejemplos en la consola de R. x &lt;- rep(1, 5) x typeof(x) xi &lt;- c(1L, 3L, 56L, 4L) xi typeof(xi) y &lt;- c(T, F, T, F, F, T) z &lt;- c(&quot;a&quot;, &quot;aba&quot;, &quot;andrea&quot;, &quot;b&quot;, &quot;bueno&quot;) Dijimos que la función typeof permitía preguntarle a un objeto qué tipo de dato es. La función class permite hacer una pregunta similar. La diferencia radica en el punto de vista: el primero da el tipo del objeto como un objeto en R mientras que, el segundo identifica el tipo del objeto desde el punto de vista de la programación orientada a objetos en R. class(z) ## [1] &quot;integer&quot; Otra función útil es str pues permite desplegar en forma compacta la estructura interna de un objeto en R: str(z) ## int [1:3] 1 2 3 3.3.2.3 Operaciones con vectores Aritmética: por default, se realizan componente a componente. a &lt;- c(1:5) b &lt;- a + 10 b ## [1] 11 12 13 14 15 c &lt;- sqrt(b) # square root = raíz c ## [1] 3.316625 3.464102 3.605551 3.741657 3.872983 a + c ## [1] 4.316625 5.464102 6.605551 7.741657 8.872983 10 * (a + c) ## [1] 43.16625 54.64102 66.05551 77.41657 88.72983 a^2 ## [1] 1 4 9 16 25 a * c ## [1] 3.316625 6.928203 10.816654 14.966630 19.364917 Agregar elementos aun vector ya creado a &lt;- c(a, 7) a ## [1] 1 2 3 4 5 7 Para construir datos rápido, podemos usar comandos como rep, seq o distintas distribuciones, e.g., la normal rnorm, uniformes runif o cualquiera en esta lista. Prueba lo siguiente: # Dame un vector donde el minimo sea 0, maximo 1 en intervalos de 0.25 seq(0, 1, 0.25) # Vector con 10 unos rep(1, 10) # 5 realizaciones de una normal(0,1) rnorm(5) # De una normal(10, 5) rnorm(5, mean = 10, sd = sqrt(5)) # De una uniforme(0,1) runif(5) # De una uniforme(5, 15) runif(5, min = 5, max = 15) 3.3.2.4 Atributos de un vector Cada objeto tiene atributos. Hay atributos específicos para vectores que, sin importar su clase, tienen en común. Ya revisamos algunos: tamaño (length), clase (class). También son importantes atributos como los nombres calificaciones &lt;- c(6, 5, 8, 9, 10) names(calificaciones) &lt;- c(&quot;Maria&quot;, &quot;Jorge&quot;, &quot;Miguel&quot;, &quot;Raúl&quot;, &quot;Carla&quot;) attributes(calificaciones) ## $names ## [1] &quot;Maria&quot; &quot;Jorge&quot; &quot;Miguel&quot; &quot;Raúl&quot; &quot;Carla&quot; # O llamamos directo a los nombres names(calificaciones) ## [1] &quot;Maria&quot; &quot;Jorge&quot; &quot;Miguel&quot; &quot;Raúl&quot; &quot;Carla&quot; 3.3.2.5 Coerción Los vectores solo permiten tener objetos del mismo tipo. Hay coercioń explícita (explicit coercion, también llamada cast) utilizando as.&lt;nombre_clase&gt;. as.numeric() as.character() as.integer() as.logical() Utilizando coerción explícita garantizamos siempre tener el resultado en cuanto a la clase del objeto. c(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), as.character(c(1, 2, 3))) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; Realizar coerción explícita implica trabajar extra y, a veces, no se puede realizar de manera directa: los datos pueden venir sucios con varios tipos de datos mezclados en una misma variable. R mezcla distintos tipos de datos y realiza una coerción implícita utilizando reglas razonables. En otras palabras, R realiza una coerción explícita por default entre los objetos y “decide” cuál es la clase del vector. # Número + caracter = caracter c(1.7, &quot;a&quot;) ## [1] &quot;1.7&quot; &quot;a&quot; # Lógico + número = número c(TRUE, 2) ## [1] 1 2 # Número + caracter = caracter c(&quot;a&quot;, TRUE) ## [1] &quot;a&quot; &quot;TRUE&quot; En ese proceso, puede haber pérdidas de información, por ejemplo, al mezclar valores lógicos con numéricos, Se confunden valores verdaderos con un uno. Hay que tener cuidado particularmente cuando se limpian los datos: c(c(T, T, T), c(1, 2, 3)) ## [1] 1 1 1 1 2 3 Hay conversiones que no tienen sentido y generan pérdida de información total: x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## [1] NA NA NA as.logical(x) ## [1] NA NA NA Normalmente, se obtiene un mensaje de advertencia (warning) cuando alguna coerción puede derivar en pérdida de información (Wickham 2014). La última consideración importante es que para R un objeto no es igual, aunque no se pierda información, si su tipo no es el mismo x &lt;- 0:5 identical(x, as.numeric(x)) ## [1] FALSE En este ejemplo, cuando declaramos \\(x\\) no especificamos su clase y R decidió que era entero. Al coercionar al objeto para que fuese numérico, R no considera a los dos objetos iguales. En general, la coersión de R es muy útil pues permite incluso comparar objetos de distintas clases si el resultado tiene sentido 1 &lt; &quot;2&quot; ## [1] TRUE Lo importante es recordar que es importante revisar las advertencias que R arroja a la consola y verificar que el resultado obtenido es el deseado o que la pérdida de información no se puede evitar. 3.3.2.6 Extraer partes del vector R tiene constructos que permite acceder a elementos individuales o subconjuntos de un vector a través de operaciones de indexación (indexing) (R Core Team 2016a, sección “Indexing”). Para los vectores, es posible acceder al i-ésimo elemento usando x[i]. x &lt;- c(10, 20, 30, 40, 50) names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # Accedemos al 4to elemento x[4] ## d ## 40 Además de la indexación con un entero, se puede # x[i] - caso anterior # x[[i]] x[[4]] ## [1] 40 # x[&quot;a&quot;] - por nombre (cuando existen) x[&quot;a&quot;] ## a ## 10 # Se puede extraer un subconjunto x[1:3] ## a b c ## 10 20 30 [] vs. [[]] Estas dos formas de acceder a los elementos de un vector (utilizados también en otras estructuras de datos) suelen causar confusión. En vectores, [[ casi no se utiliza, aunque son ligeramente diferentes. Como vimos en el ejemplo, [[ quita los nombres o atributos y permite extraer únicamente un elemento a la vez. 3.3.3 Matrices Las matrices son un tipo especial de vectores. Son un vector atómico con una dimensión adicional pues tienen filas y columnas. m &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2) m ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 En términos de sus atributos por default, la diferencia entre los vectores y las matrices es: x &lt;- c(1, 2, 3, 4) attributes(x) ## NULL attributes(m) ## $dim ## [1] 2 2 Como puedes notar, las matrices se forman por default usando los elementos del vector para llenar columna por columna de izquierda a derecha. Podemos simplemente “agregarle” una dimensión a un vector para construir una matriz. m &lt;- 1:10 m ## [1] 1 2 3 4 5 6 7 8 9 10 dim(m) &lt;- c(2, 5) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 También podemos pegar o concatenar vectores de la misma longitud como si fueran columnas de una matriz usando cbind o como si fueran filas rbind (r = row, c = column). x &lt;- runif(4) y &lt;- rnorm(4) cbind(x, y) ## x y ## [1,] 0.96287589 -0.3065290 ## [2,] 0.01111454 0.6312563 ## [3,] 0.82282778 -0.8850892 ## [4,] 0.42547561 0.3376346 rbind(x, y) ## [,1] [,2] [,3] [,4] ## x 0.9628759 0.01111454 0.8228278 0.4254756 ## y -0.3065290 0.63125627 -0.8850892 0.3376346 Le agregamos atributos para accesar más fácilmente a los objetos. m &lt;- matrix(c(x, y), nrow = 4, ncol = 2, byrow = T, dimnames = list(paste0(&quot;row&quot;, 1:4), paste0(&quot;col&quot;, 1:2))) m ## col1 col2 ## row1 0.9628759 0.01111454 ## row2 0.8228278 0.42547561 ## row3 -0.3065290 0.63125627 ## row4 -0.8850892 0.33763458 dimnames(m) ## [[1]] ## [1] &quot;row1&quot; &quot;row2&quot; &quot;row3&quot; &quot;row4&quot; ## ## [[2]] ## [1] &quot;col1&quot; &quot;col2&quot; Acceder a elementos de una matriz puede hacerse de muchas formas # m[i] - quinto elemento, contando desde entrada 1,1 por columnas m[5] ## [1] 0.01111454 # m[[i]] - quinto elemento, quitando atributos m[[5]] ## [1] 0.01111454 # m[i, j] - mismo elemento que m[5] pero usando notacion fila, columna m[1, 2] ## [1] 0.01111454 # m[[i, j]] - mismo elemento, quitando atributos m[[1, 2]] ## [1] 0.01111454 # Puedo llamar por su nombre m[&quot;row1&quot;, &quot;col2&quot;] ## [1] 0.01111454 # Misma forma, quitando atributos m[[&quot;row1&quot;, &quot;col2&quot;]] ## [1] 0.01111454 # m[i, ] - toda la fila i-ésima m[1, ] ## col1 col2 ## 0.96287589 0.01111454 # m[, j] - toda la columna j-ésima m[, 2] ## row1 row2 row3 row4 ## 0.01111454 0.42547561 0.63125627 0.33763458 # Índices o nombres son equivalentes m[1, 1] == m[&quot;row1&quot;, &quot;col1&quot;] ## [1] TRUE [] vs. [[]] En matrices, [[ casi no se utiliza. Como vimos en el ejemplo, [[ quita los nombres o atributos y permite extraer únicamente un elemento a la vez. 3.3.4 Listas Tiene características muy similares a un vector pero permite que cada elemento sea de un tipo distinto. Mas aún, es posible incluir una lista como un elemento de otra lista y por eso también se les conoce como vectores recursivos (recursive vectors) (Wickham 2014, sección “lists”). Para crear una lista vacía utilizas list() y para coercionar un objeto a una lista usa as.list(). x &lt;- list(3L, 3.56, 1 + 4i, TRUE, &quot;hola&quot;, list(&quot;genial&quot;, 1)) length(x) ## [1] 6 class(x) ## [1] &quot;list&quot; class(x[1]) ## [1] &quot;list&quot; class(x[[1]]) ## [1] &quot;integer&quot; y &lt;- as.list(1:10) length(y) ## [1] 10 Nota como muchas propiedades que tenían los vectores atómicos los tienen también las listas. Las listas también pueden tener nombres # Lista vacia lista &lt;- list() # Concatenamos un vector lista[[&quot;numeros&quot;]] &lt;- c(1, 34, 45.5, 34) # Concatenamos un objeto de datos lista[[&quot;datos&quot;]] &lt;- head(iris) # Concatenamos un número lista &lt;- c(lista, 3) # ¡No le tuvimos que poner nombre! lista ## $numeros ## [1] 1.0 34.0 45.5 34.0 ## ## $datos ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## [[3]] ## [1] 3 R tiene muchos datos de ejemplo que son utilizados en muchos paquetes, blogs y libros. Utiliza help(iris) para saber más del dataset usado arriba. Por su propiedad recursiva, se navega diferente. Repasamos las principales maneras de extraer los elementos de la lista utilizando la lista \\(x\\) declarada anteriormente: # Recordamos a x x ## [[1]] ## [1] 3 ## ## [[2]] ## [1] 3.56 ## ## [[3]] ## [1] 1+4i ## ## [[4]] ## [1] TRUE ## ## [[5]] ## [1] &quot;hola&quot; ## ## [[6]] ## [[6]][[1]] ## [1] &quot;genial&quot; ## ## [[6]][[2]] ## [1] 1 # x[i] - el i-ésimo elemento de la lista x[3] ## [[1]] ## [1] 1+4i ## Nota como la clase del objeto sigue siendo lista class(x[3]) ## [1] &quot;list&quot; # x[[i]] - el i-ésimo elemento de la lista x[[3]] ## [1] 1+4i ## La clase ahora es la del objeto dentro del &quot;espacio&quot; 3 en la lista original class(x[[3]]) ## [1] &quot;complex&quot; # Nombramos la lista names(x) &lt;- c(&quot;entero&quot;, &quot;numerico&quot;, &quot;complejo&quot; , &quot;booleano&quot;, &quot;caracter&quot;, &quot;lista&quot;) # Ganamos formas de accesar los objetos # x$a - llamamos al elemento con nombre &quot;a&quot; x$entero ## [1] 3 class(x$entero) # Es equivalente a [[]] ## [1] &quot;integer&quot; # x$&quot;a&quot; x$&quot;complejo&quot; ## [1] 1+4i # x[[&quot;lista&quot;]][i] - i-ésimo elemento de la lista dentro de la lista x[[&quot;lista&quot;]][1] ## [[1]] ## [1] &quot;genial&quot; # x[[j]][i] - Mismas reglas en la lista anidada x[[6]][1] ## [[1]] ## [1] &quot;genial&quot; # x[[j]][[i]] - i-ésimo elemento en la lista del j-ésimo elemento de x x[[6]][[1]] ## [1] &quot;genial&quot; [] vs. [[]] En listas, [[ es fundamental para accesar correctamente los objetos y poder navegar la lista. Como en vectores y matrices, [[ quita los nombres o atributos y permite extraer únicamente un elemento a la vez. En listas, además, devuelve el objeto dentro del i-ésimo elemento. Por el contrario, [ devuelve una lista. Puedo poner listas dentro de listas, dentro de listas… Se navega en orden como en el ejemplo. Las longitudes de los objetos en la lista se pueden pensar por niveles, por su propiedad recursiva. # El tamaño es del &quot;primer nivel&quot;. length(x) ## [1] 6 # Hay 6 elementos en x, todos de diferentes tipos names(x) ## [1] &quot;entero&quot; &quot;numerico&quot; &quot;complejo&quot; &quot;booleano&quot; &quot;caracter&quot; &quot;lista&quot; # Para obtener la longitud dentro del i-ésimo elemento de la lista, debo length(x[[6]]) # La lista anidada tiene 2 elementos ## [1] 2 # que no es lo mismo que length(x[6]) # Donde hay un solo elemento: una lista ## [1] 1 3.3.5 Factores (factor) Los factores son otro tipo de vectores pero que ayuda a representar datos del tipo categórico u ordinal, es decir, cuando los posibles valores de la variable tipo caracter es limitado. Por ejemplo, son útiles cuando tenemos una variable como “sexo” donde, al menos por ahora, legalmente solo puede tomar los valores hombre o mujer. Si, en cambio, se tiene un vector de nombres es conveniente dejarlo como caracter. Un factor se guarda como un enteros pero con etiquetas encima tal que cada entero corresponde a una etiqueta (label). y &lt;- c(&quot;no&quot;, &quot;si&quot;, &quot;si&quot;, &quot;no&quot;) class(y) ## [1] &quot;character&quot; # Debemos pedirle explícitamente que lo guarde como factor x &lt;- factor(c(&quot;no&quot;, &quot;si&quot;, &quot;si&quot;, &quot;no&quot;)) x ## [1] no si si no ## Levels: no si Al imprimir el objeto, se observa como los niveles fueron asignados. Éstos corresponden al número de valores únicos en el vector de caracter y se asignan en orden alfabético los valores. Los factores se despliegan como si fueran vectores tipo caracter y algunas operaciones son análogas: table(x) ## x ## no si ## 2 2 La ganancia es que son más rápidas. Aunque a veces los factores se comportan como vectores tipo caracter pero debemos recordar que por debajo son enteros y tenemos que ser cuidadosos si los tratamos como caracteres. Supongamos por ejemplo que tenemos un factor con valores 5, 6 o 7. Lo tenemos guardado como factor. ej &lt;- factor(c(&quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;7&quot;, &quot;5&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;5&quot;, &quot;6&quot;,&quot;5&quot;)) ej ## [1] 7 6 5 7 5 7 6 5 5 6 5 ## Levels: 5 6 7 Dado que los valores son números, conceptualmente tiene sentido operarlos como tal: as.integer(ej) ## [1] 3 2 1 3 1 3 2 1 1 2 1 Obtuvimos los enteros a los que las etiquetas originales habían sido asignados. Para recuperar los valores originales, debemos hacer as.integer(as.character(ej)) ## [1] 7 6 5 7 5 7 6 5 5 6 5 Algunos métodos que están hechos para caracteres coercionan un factor a caracter mientras que otros arrojan un error. Si usas métodos de caracteres, lo mejor es “castear” (coerción explícita) a caracter tu factor utilizando as.character(mifactor). De esta manera se pierden algunas cosas pero te aseguras que las cosas funcionen como deben. summary(x) ## no si ## 2 2 summary(as.character(x)) ## Length Class Mode ## 4 character character Summary R funciona mejor gracias a sus convenciones, es decir, porque los contribuyentes se ponen de acuerdo en seguir ciertas reglas de manera que sea más fácil utilizar los paquetes de otros (con sus objetos y funciones). La función summary es la función genérica que produce resumenes para objetos de muchas clases. La función invoca métodos que dependen de la clase del argumento enviado (en estos ejemplos, el resumen para un factor y para un caracter respectivamente). Los factores pueden incluir únicamente los niveles con los que fueron definidos. Por esa razón, la unión de dos factores ddeclarados en forma independiente puede dar resultados no deseados. y &lt;- factor(c(&quot;si&quot;, &quot;no&quot;, &quot;tal vez&quot;)) c(x, y) ## [1] 1 2 2 1 2 1 3 class(c(x, y)) ## [1] &quot;integer&quot; No es posible entonces recuperar el valor de las etiquetas. R hizo las operaciones posibles pero hubo pérdida de información. Para concatenar dos factores correctamente, es necesario: factor(c(as.character(x), as.character(y))) ## [1] no si si no si no tal vez ## Levels: no si tal vez En general, se recomienda incluir el valor de u nnivel posible, independientemente de si se tiene o no esa respuesta. Sin embargo, el problema al concatenar persiste. x &lt;- factor(c(&quot;no&quot;, &quot;si&quot;, &quot;si&quot;, &quot;no&quot;), levels = c(&quot;no&quot;, &quot;si&quot;, &quot;tal vez&quot;)) c(x, &quot;tal vez&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;1&quot; &quot;tal vez&quot; Para datos ordinales como las respuestas en una pregunta de encuesta con escala likert7 los factores son también objetos útiles. Veamos un ejemplo en donde tenemos 500 respuestas a la pregunta “este tutorial es muy útil”: set.seed(2887) respuestas &lt;- sample(x = c(1:5), size = 500, replace = T , prob = c(0.1, 0.15, 0.2, 0.4, 0.15)) y &lt;- factor( x = respuestas, levels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;), labels = c(&quot;totalmente en desacuerdo&quot;, &quot;en desacuerdo&quot; , &quot;ni de acuerdo ni en desacuerdo&quot; , &quot;de acuerdo&quot;, &quot;totalmente de acuerdo&quot;), ordered = T) table(y) ## y ## totalmente en desacuerdo en desacuerdo ## 51 74 ## ni de acuerdo ni en desacuerdo de acuerdo ## 108 194 ## totalmente de acuerdo ## 73 Nota como la tabla está ordenada de izquierda a derecha con la respuesta más en desacuerdo a la más de acuerdo pues introducimos la opción ordered = T en la definición del factor debido a que las respuestas están en una escala ordinal. Otras funciones útiles En el ejemplo anterior, introducimos las funciones: set.seed: sirve para fijar la semilla con la que se generan números aleatorios. Esto es importante pues al fijarla se puede reproducir exactamente el mismo vector de respuestas cuantas veces sea necesario. sample: permite extraer muestras de un vector x especificando el tamaño de la muestra, si es muestreo con reemplazo y permite establecer pesos para el muestreo. table(y) ## y ## totalmente en desacuerdo en desacuerdo ## 51 74 ## ni de acuerdo ni en desacuerdo de acuerdo ## 108 194 ## totalmente de acuerdo ## 73 Por último, al utilizar factores (y más aún, declarar un orden cuando es conceptualmente pertinente) es más fácil visualizar correctamente los datos con menor desgaste. Si graficamos las respuestas como caracter recibimos: library(ggplot2) df &lt;- data.frame(como.caracter = as.character(y), como.factor = y) ggplot(df, aes(x = como.caracter)) + geom_bar() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) Si utilizamos el factor ordenado obtenemos: ggplot(df, aes(x = como.factor)) + geom_bar() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) Nota En R muchas cosas son más fáciles si se utliza la estructura de datos apropiada y se establecen correctamente todos los metadatos necesarios al objeto para que los defaults de R faciliten el trabajo. Al utilizar factores cuando es pertinente se gana, al menos, lo siguiente: Se almacenan los datos usando menos memoria. Esto es importante pues R trabaja en ram. El rendimiento es mejor que usando caracteres. Por default R utiliza los métodos apropiados para el tipo de variable. Por ejemplo, si se introduce un factor como variable dependiente en un modelo de regresión, automáticamente aplica un logit y no un ols. Se pueden especificar elementos, como el orden de los niveles, que son útiles para el análisis y presentación de resultados. A pesar de sus ventajas, si son incorrectamente utilizados las estructuras de datos pueden resultar en pérdidas de información o comportamientos indeseados. 3.3.6 Data frames Los dataframes son una de las estructuras de datos más importantes para guardar datos en R (Wickham 2014, sección “Data frames”). En python, existe una estructura similar en la librería pandas creado para facilitar el análisis de datos en este lenguaje sin la necesidad de cambiar a un lenguaje de dominio específico como R (McKinney 2010, sección “What problem does pandas solve?”). Este objeto es tan importante porque muchos de los modelos estadísticos que se utliizan necesitan una estructura de datos tabular. Los dataframes tienen atributos adicionales a los que tienen los vectores: rownames() colnames() names() head() te enseña las primeras 6 lineas. tail() te enseña las últimas 6 líneas. nrow() te da el número de filas ncol() te da el número de columnas str() te dice el tipo de cada columna y te muestra ejemplos Podemos ver a los dataframes como un tipo de lista con algunas restricciones (R Core Team 2016a, sección “Data frames”): Los componentes deben ser vectores, factores, matrices numéricas, listas u otros dataframes. Las matrices, listaa y otros data frames proveen de tantas columnas, elementos o variables como las originales, respectivamente. Los vectores numéricos, lógicos y factores se incluyen en el dataframe sin transformaciones adicionales. Los vectores tipo caracter se coercionan a factores. Todos los elementos (las columnas) deben tener la misma longitud o tamaño. Los dataframes se pueden crear utilizando comandos como read.table() (que tiene como caso particular read.csv(). Se verá con detalle el uso de estas funciones en la sección 5.1. Para convertir un dataframe a una matriz se utiliza data.matrix(). La coerción es forzada y no necesariamente da lo que uno espera. Se pueden crear data.frames con la función data.frame(). df &lt;- data.frame( x = rnorm(10), y = runif(10), n = LETTERS[1:10], stringsAsFactors = F # F = FALSE, T = TRUE ) head(df) ## x y n ## 1 0.89814648 0.52584158 A ## 2 -0.37532709 0.68789829 B ## 3 -2.17112789 0.60079780 C ## 4 -0.63011959 0.86922537 D ## 5 0.03778982 0.44119997 E ## 6 0.35565256 0.02638035 F dim(df) ## [1] 10 3 str(df) ## &#39;data.frame&#39;: 10 obs. of 3 variables: ## $ x: num 0.8981 -0.3753 -2.1711 -0.6301 0.0378 ... ## $ y: num 0.526 0.688 0.601 0.869 0.441 ... ## $ n: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ¿Por qué usar la opción stringsAsFactors = F? Por default las columnas tipo caracter en un dataframe son convertidas a factor. Esto es útil cuando se tienen los datos limpios y se va a proceder a modelas sin realizar mayores transformaciones o limpiezas a los datos. Sin embargo, cuando se realizarán manipulaciones a los mismos, es recomendable cambiar la opción por default para leer columnas como caracter, de esta forma se evitan los problemas mencionados en la sección de factores. Es posible concatenar columnas o filas: df &lt;- cbind(df, data.frame(z = rexp(10))) df &lt;- rbind(df, c(rnorm(1), runif(1), &quot;K&quot;, rexp(1))) dim(df) ## [1] 11 4 Repasamos las principales maneras de extraer los elementos de un dataframe utilizando el objeto \\(df\\): df &lt;- data.frame( x = rnorm(4), y = runif(4), n = LETTERS[1:4], stringsAsFactors = F # F = FALSE, T = TRUE ) # df[i] df[1] # La primera columna ## x ## 1 0.38112864 ## 2 0.51810269 ## 3 -0.84698783 ## 4 0.03558633 class(df[1]) # Regresa un dataframe ## [1] &quot;data.frame&quot; # df[[i]] df[[1]] # La primera columna ## [1] 0.38112864 0.51810269 -0.84698783 0.03558633 class(df[[1]]) # Regresa un vector ## [1] &quot;numeric&quot; # df[i, j] df[1,2] # elemento en la primera fila, segunda columna ## [1] 0.5346584 # df[[i, j]] df[[1, 2]] # mismo resultado ## [1] 0.5346584 # df$columna df$x # La columna llamada x ## [1] 0.38112864 0.51810269 -0.84698783 0.03558633 # df$&quot;columna&quot; df$&quot;x&quot; ## [1] 0.38112864 0.51810269 -0.84698783 0.03558633 df[[&quot;n&quot;]][1] # Podemos navegar igual que en una lista ## [1] &quot;A&quot; [] vs. [[]] Debido a que los dataframes son un caso particular de las listas, [[ es también fundamental para accesar correctamente los objetos. [[ quita los nombres o atributos, permite extraer únicamente un elemento a la vez y devuelve el objeto dentro del i-ésimo elemento. [ devuelve un data frame con la columna(s) que sea nombradas o los índices que sean utilizados. Cuando se declara un dataframe automáticamente se verifican que los nombres sean sintácticamente válidos con la función make.names data.frame(&quot;2000&quot; = c(100:104) , &quot;una-variable&quot; = c(200:204) , &quot;.2000&quot; = c(300:304) ) ## X2000 una.variable X.2000 ## 1 100 200 300 ## 2 101 201 301 ## 3 102 202 302 ## 4 103 203 303 ## 5 104 204 304 Nombres sintácticamente válidos Los dataframes pueden tener únicamente nombres sintácticamente válidos (Hornik 2016, sección “What are valid names?”): Está compuesto por letras, números, puntos o guiones bajos. No deben empezar con números. Tampoco pueden empezar con un punto seguido de un número. No se permiten palabras reservadas (if, else, repeat, next, TRUE, FALSE, entre otras). Bibliografía "],
["estructuras-de-datos-fuera-de-r-basico.html", "3.4 Estructuras de datos fuera de R-básico", " 3.4 Estructuras de datos fuera de R-básico Fuera del R Core Team (2016b), se han desarrollado otras estructuras de datos particularmente útiles para hacer análisis de datos. Hay paquetes compatibles con este tipo de estructuras que facilitan el trabajo. A continuación presentaremos data.tables y tibbles que sustituyen el data.frame. Ambos se coercionan a dataframe de manera automática cuando se llama a una función que contiene únicamente métodos para dataframe. 3.4.1 Data tables data.table provee una versión de alto rendimiento para los dataframes del R Core Team (2016b). Está implementado en el paquete del mismo nombre (Dowle et al. 2015). Un data.table se crea en forma análoga a un data.frame. En la sección anterior, creamos un objeto llamado \\(df\\) df &lt;- data.frame( x = rnorm(4), y = runif(4), n = LETTERS[1:4], stringsAsFactors = F ) Usamos la función data.table(): library(data.table) dt &lt;- data.table( x = rnorm(4), y = runif(4), n = LETTERS[1:4] ) str(dt) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 4 obs. of 3 variables: ## $ x: num 1.777 1.024 0.952 -0.492 ## $ y: num 0.0295 0.9999 0.4618 0.6732 ## $ n: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; class(dt) ## [1] &quot;data.table&quot; &quot;data.frame&quot; Por default los vectores tipo caracter son leidos as-is, es decir, sin coercionar a factor. El objeto con clase data.table retiene todos los atributos del data.frame. Podemos usar las funciones: head, names, Para crear data.tables se puede coercionar cualquier data.frame con as.data.table(diamonds) ## carat cut color clarity depth table price x y z ## 1: 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2: 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3: 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4: 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63 ## 5: 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## --- ## 53936: 0.72 Ideal D SI1 60.8 57 2757 5.75 5.76 3.50 ## 53937: 0.72 Good D SI1 63.1 55 2757 5.69 5.75 3.61 ## 53938: 0.70 Very Good D SI1 62.8 60 2757 5.66 5.68 3.56 ## 53939: 0.86 Premium H SI2 61.0 58 2757 6.15 6.12 3.74 ## 53940: 0.75 Ideal D SI2 62.2 55 2757 5.83 5.87 3.64 Nota como los datatables tienen por default una impresión diferente que un dataframe pues imprimen los primeros y los últimos 6 renglones. Los data.tables incorporan nuevas maneras de extraer objetos, agruparlos y juntarlos con otras tablas. Para más detalles, se pueden revisar las viñetas del paquete: Item Title datatable-benchmarking Benchmarking data.table (source, html) datatable-reshape Efficient reshaping using data.tables (source, html) datatable-faq Frequently asked questions (source, html) datatable-importing Importing data.table (source, html) datatable-intro Introduction to data.table (source, html) datatable-keys-fast-subset Keys and fast binary search based subset (source, html) datatable-reference-semantics Reference semantics (source, html) datatable-secondary-indices-and-auto-indexing Secondary indices and auto indexing (source, html) Para ver una viñeta en específico se puede usar vignette(&quot;datatable-faq&quot;, package = &quot;data.table&quot;). Viñetas Todos los paquetes tienen viñetas en donde se documentan en forma más detallada sus funciones, clases y métodos. 3.4.2 Tibbles Los tibbles son escencialmente dataframes pero con algunas modificaciones a los defaults para facilitar el trabajo (Wickham and Grolemund 2016, ver sección “tibbles”). Un tibble se crea en forma análoga a un data.frame. En la sección , creamos un objeto llamado \\(df\\) df &lt;- data.frame( x = rnorm(4), y = runif(4), n = LETTERS[1:4], ) Usamos la función tibble() del paquete Wickham, Francois, and Müller (2016): library(tibble) tb &lt;- tibble( x = rnorm(4), y = runif(4), n = LETTERS[1:4] ) str(tb) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 4 obs. of 3 variables: ## $ x: num 0.208 1.155 0.731 -0.214 ## $ y: num 0.146 0.895 0.418 0.809 ## $ n: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; class(tb) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Para crear tibbles se puede coercionar cualquier data.frame con as_tibble(diamonds) ## # A tibble: 53,940 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4.00 4.05 2.39 ## # ... with 53,930 more rows Los tibbles, como los datatables tienen una impresión diferente que un dataframe. En este caso, se imprime la dimensión y los primeros 10 renglones. Al crear un tibble nunca hay conversión de tipos (no se convierte de caracter a factor), no se cambian los nombres de las variables y no se crean nombres para las filas. Se permite también tener nombres de variables que no son sintácticamente válidos, para utilizar estos nombres, se declaran con acento invertido ``` tibble( `2000` = c(100:104) , `una-variable` = c(200:204) , `año` = c(300:304) ) ## # A tibble: 5 × 3 ## `2000` `una-variable` año ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 100 200 300 ## 2 101 201 301 ## 3 102 202 302 ## 4 103 203 303 ## 5 104 204 304 Para utilizar nombres no sintácticamente válidos es necesario conjugarlos con el acento invertido al nombrarlos en otros paquetes como dplyr, ggplot2, entre otros que son compatibles con el objeto tibble. La otra diferencia importante entre los tibbles y los data.frames es que pueden incorporar elementos de listas en una columna en forma sencilla (Wickham 2016). try(df &lt;- data.frame(x = list(1:2, 3:5))) df&lt;- data.frame(x = I(list(1:2, 3:5))) df ## x ## 1 1, 2 ## 2 3, 4, 5 tb &lt;- tibble(x = list(1:2, 3:5)) tb ## # A tibble: 2 × 1 ## x ## &lt;list&gt; ## 1 &lt;int [2]&gt; ## 2 &lt;int [3]&gt; Bibliografía "],
["objetos-importantes.html", "3.5 Objetos importantes", " 3.5 Objetos importantes 3.5.1 Infinito Inf es como R denomina al infinito. En el mundo de R se permite también positivo o negativo. 1/0 ## [1] Inf 1/Inf ## [1] 0 3.5.2 No es un número NaN es como R denota a algo que no es un número (literal: not a number). 0/0 ## [1] NaN 3.5.3 Valores perdidos (missing values) En la sección 3.5 se habló de otros objetos en R. De particular importancia es NA para valores perdidos en general y NaN para operaciones matemáticas no definidas. Lógicamente, podemos preguntar a R si un objeto es de este tipo is.na() is.nan() Los valores NA tienen una clase particular. Puede haber valores perdidos enteros NA_integer_ o caracteres NA_character_. NaN es un NA pero no al revés. x &lt;- c(1, 4, 6, NA, NaN, 45) is.nan(x) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE is.na(x) ## [1] FALSE FALSE FALSE TRUE TRUE FALSE Cuando tenemos un dataframe que tiene valores perdidos y lo queremos incorporar, por ejemplo, a un modelo de regresión, lo primero que hará el método es excluir todos los renglones que tengan algún valor perdido usando na.exclude(datos). Normalmente, este no es el tratamiento deseado para valores perdidos pero es el comportamiento por default. "],
["estructuras-de-control.html", "3.6 Estructuras de control", " 3.6 Estructuras de control Las estructuras de control permiten controlar la ejecución. Pueden ser utilizadas en un script o dentro de funciones. Entre las más comunes se encuentran: if, else for while repeat break next return 3.6.1 If if ( condicion ) { # Cuando se cumple la condicion, ejecuta esto } else { # Para todo lo que no se cumple la condicion, ejecuta esto } Ejemplo, x &lt;- 1:20 if ( sample(x, 1) &lt;= 10 ) { print(&quot;x es menor o igual que 10&quot;) } else { print(&quot;x es mayor que 10&quot;) } ## [1] &quot;x es menor o igual que 10&quot; O lo que es lo mismo: ifelse(sample(x, 1) &lt;= 10, &quot;x es menor o igual que 10&quot;, &quot;x es mayor que 10&quot;) ## [1] &quot;x es menor o igual que 10&quot; También es posible asignar variables dentro de una condición. if ( sample(x, 1) &lt;= 10 ){ y &lt;- 0 } else { y &lt;- 1 } # o y &lt;- if ( sample(x, 1) &lt;= 10 ){ 0 } else { 1 } 3.6.2 For Un ciclo for itera una variable y va realizando, para cada iteración, la secuencia de comandos que se especifica dentro del mismo. for (i in 1:3 ){ print(paste0(&quot;i vale: &quot;, i)) } ## [1] &quot;i vale: 1&quot; ## [1] &quot;i vale: 2&quot; ## [1] &quot;i vale: 3&quot; Es posible también iterar directamente sobre vectores o partes de vectores. x &lt;- c(&quot;Andrea&quot;, &quot;Liz&quot;, &quot;Edwin&quot;, &quot;Miguel&quot;) for ( i in seq(x) ) { print(x[i]) } ## [1] &quot;Andrea&quot; ## [1] &quot;Liz&quot; ## [1] &quot;Edwin&quot; ## [1] &quot;Miguel&quot; for ( e in x ) { print(e) } ## [1] &quot;Andrea&quot; ## [1] &quot;Liz&quot; ## [1] &quot;Edwin&quot; ## [1] &quot;Miguel&quot; for ( i in seq(x) ){ print(x[i]) } for ( i in 1:length(x) ) print(x[i]) Podemos incluir fors dentro de fors. m &lt;- matrix(1:10, 2) for( i in seq(nrow(m)) ) { for ( j in seq(ncol(m)) ) { print(m[i, j]) } } 3.6.3 Whiles Otra manera de iterar sobre comandos es con la estructura while. A diferencia del for, esta te permite iterar sobre la secuencia de comandos especificada hasta que se cumpla cierta condición lógica. Esta última tiene que variar a lo largo de las iteraciones o es posible generar ciclos infinitos. Esta estructrura da mucha flexibilidad. x &lt;- runif(1) while ( x &lt; 0.20 | i &lt;= 10 ) { print(x) x &lt;- runif(1) i &lt;- i + 1 } Importante Asegurate de especificar una manera de salir de un ciclo while. 3.6.4 Repeat - Break x &lt;- 1 repeat { # Haz algo print(x) x = x+1 # Hasta que se cumpla lo siguiente if (x == 6){ break } } 3.6.5 Next for (i in 1:20) { if (i %% 2 == 0){ next } else { print(i) } } Este ciclo itera sobre los valores del 1 al 20 e imprime los valores impares. Importante R no es muy eficiente cuando se combina con estructuras de control tipo for o while. Sin embargo, estas estructuras son muy comunes y es útil conocerlas. Normalmente, se recomienda utilizar estructuras vectorizadas (como ifelse) pues, de esta manera, R es mucho más eficiente. "],
["material-adicional-1.html", "3.7 Material adicional", " 3.7 Material adicional Curso de swirl R Programming, módulos 4 a 9. Curso Introduction to R de Data Camp. Curso TryR de Code School. "],
["vectorizacion-la-familia-apply-y-otros.html", "Capítulo 4 Vectorización, la familia apply y otros", " Capítulo 4 Vectorización, la familia apply y otros En este capítulo se profundiza en la forma en la que es posible operar los distintos objetos examinados en el capítulo anterior. En particular, se revisa con detalle las diferentes maneras con las que se pueden extraer subconjuntos de las estructuras de datos. Para vectores, se detallan los seis tipos de extracciones y, posteriormente, se describe cómo esos seis métodos aplican en matrices y dataframes. Se describe la asignación de valores a los subconjuntos extraídos, así como los operadores lógicos disponibles en R y sus particularidades. Se introducen también distintas aplicaciones del material revisados de forma que sea posible realizar operaciones que típicamente se hacen en Excel, como buscarv o buscarh. Se revisa cómo expandir una base con pesos, cómo seleccionar muestras aleatorias y cómo generar datos a partir de realizaciones de distribuciones específicas implementadas en R. Por último, se revisa la estrategia separa, aplica y combina (SAC), así como su implementación en R básico en la familia apply Esta estrategia permitirá que fácilmente se realicen operaciones complejas sobre grupos, especificando explícitamente la estructura de datos de entrada y de salida que se está buscando. "],
["subconjuntos-de-diferentes-estructuras-de-datos.html", "4.1 Subconjuntos de diferentes estructuras de datos", " 4.1 Subconjuntos de diferentes estructuras de datos Esta sección está basada en (Wickham 2014, Subsetting) disponible en línea. Aprender a extraer subconjuntos de los datos es importante y permite realizar operaciones complejas con los mismos. De los conceptos importantes que se deben aprender son Los operadores para extraer subconjuntos (subsetting operators) Los 6 tipos de extracciones de subconjuntos Las diferencias a la hora de extraer subconjuntos de las diferentes estructuras de datos (factores, listas, matrices, dataframes) El uso de la extracción de subconjuntos junto a asignar variables. Cuando tenemos que extraer pedazos de los datos (o analizar solamente parte de éstos), necesitamos complementar str() con [[, es decir, la estructura nos dirá cómo utilizar el operador subconjunto de manera que de hecho extraigamos lo que queremos. 4.1.1 Operadores para extraer subconjuntos Dependiendo la estructura de datos que tenemos, será la forma en la que extraemos elementos de ella. Hay dos operadores de subconjunto: [[ y $. [[ se parece a [ pero regresa un solo valor y te permite sacar pedazos de una lista. $ es un atajo útil para [[. 4.1.1.1 Vectores atómicos ¿De qué formas puedo extraer elementos de un vector? Hay varias maneras sin importar la clase del vector. Enteros positivos regresan los elementos en las posiciones especificadas en el orden que especificamos. x &lt;- c(5.6, 7.8, 4.5, 3.3) x[c(3, 1)] ## [1] 4.5 5.6 ## Si duplicamos posiciones, nos regresa resultados duplicados x[c(1, 1, 1)] ## [1] 5.6 5.6 5.6 ## Si usamos valores reales, se coerciona a entero x[c(1.1, 2.4)] ## [1] 5.6 7.8 x[order(x)] ## [1] 3.3 4.5 5.6 7.8 x[order(x, decreasing = T)] ## [1] 7.8 5.6 4.5 3.3 Enteros negativos omiten los valores en las posiciones que se especifican. x ## [1] 5.6 7.8 4.5 3.3 x[-c(3, 1)] ## [1] 7.8 3.3 Mezclar no funciona. x[c(-3, 1)] Vectores lógicos selecciona los elementos cuyo valor correspondiente es TRUE. Esta es una de los tipos más útiles. x[c(TRUE, TRUE, FALSE, FALSE)] ## [1] 5.6 7.8 x[c(TRUE, FALSE)] # Autocompleta el vector lógico al tamaño de x ## [1] 5.6 4.5 x[c(TRUE, TRUE, NA, FALSE)] ## [1] 5.6 7.8 NA Nada si no especifico nada, me regresa el vector original x[] ## [1] 5.6 7.8 4.5 3.3 Cero el índice cero no aplica en R, te regresa el vector vacio x[0] ## numeric(0) Si el vector tiene nombres también los puedo usar. names(x) &lt;- c(&quot;a&quot;, &quot;ab&quot;, &quot;b&quot;, &quot;c&quot;) x[&quot;ab&quot;] ## ab ## 7.8 x[&quot;d&quot;] ## &lt;NA&gt; ## NA x[grep(&quot;a&quot;, names(x))] ## a ab ## 5.6 7.8 Las listas operan básicamente igual a vectores recordando que si usamos [ regresa una lista y tanto [[ y $ extrae componentes de la lista. 4.1.1.2 Matrices y arreglos Para estructuras de mayor dimensión se pueden extraer de tres maneras: Con vectores múltiples Con un solo vector Con una matriz m &lt;- matrix(1:12, nrow = 3) colnames(m) &lt;- LETTERS[1:4] m[1:2, ] ## A B C D ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 m[c(T, F, F), c(&quot;B&quot;, &quot;C&quot;)] ## B C ## 4 7 m[1, 4] ## D ## 10 Como ven, es solamente generalizar lo que se hace en vectores replicándolo al número de dimensiones que se tiene. m[c(T, F, F)] ## [1] 1 4 7 10 class(m[c(T, F, F)]) ## [1] &quot;integer&quot; [ simplifica al objeto. En matriz, me quita la dimensionalidad, en listas me da lo que esta dentro de esa celda. 4.1.1.3 Dataframes df &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3]) df[c(1, 2), ] ## x y z ## 1 1 3 a ## 2 2 2 b df[, c(1, 2)] ## x y ## 1 1 3 ## 2 2 2 ## 3 3 1 df[, c(&quot;z&quot;, &quot;x&quot;)] ## z x ## 1 a 1 ## 2 b 2 ## 3 c 3 df[c(&quot;z&quot;, &quot;x&quot;)] ## z x ## 1 a 1 ## 2 b 2 ## 3 c 3 class(df[, c(&quot;z&quot;, &quot;x&quot;)]) ## [1] &quot;data.frame&quot; class(df[c(&quot;z&quot;, &quot;x&quot;)]) ## [1] &quot;data.frame&quot; str(df[&quot;x&quot;]) ## &#39;data.frame&#39;: 3 obs. of 1 variable: ## $ x: int 1 2 3 str(df[, &quot;x&quot;]) ## int [1:3] 1 2 3 str(df$x) ## int [1:3] 1 2 3 Ejercicios Utiliza la base mtcars Arregla los errores al extraer subconjuntos en dataframes mtcars[mtcars$cyl = 4, ] mtcars[-1:4, ] mtcars[mtcars$cyl &lt;= 5] mtcars[mtcars$cyl == 4 | 6, ] ¿Por qué al correr x &lt;- 1:5; x[NA] obtengo valores perdidos? Genera una matriz cuadrada tamaño 5 llamada m. ¿Qué te da correr m[upper.tri(m)]? ¿Por qué al realizar mtcars[1:20] me da un error? ¿Por qué mtcars[1:2] no me lo da? ¿Por qué mtcars[1:20, ] es distinto? Haz una función que extraiga la diagonal de la matriz m que creaste antes. Debe dar el mismo resultado que ejecutar diag(m) ¿Qué hace df[is.na(df)] &lt;- 0? 4.1.2 Asignar a un subconjunto Muchas veces lo que necesitamos es encontrar ciertos valores para poder reemplazarlos con algo más. Por ejemplo, muchas veces queremos imputar valores perdidos con cierto valor. # Variables continuas x &lt;- c(1, 2, 3, NA, NaN, 7) media &lt;- mean(x, na.rm = T) media ## [1] 3.25 x[is.na(x)] &lt;- media x ## [1] 1.00 2.00 3.00 3.25 3.25 7.00 # Variables discretas x &lt;- c(rep(&quot;azul&quot;, 3), &quot;verde&quot;, NA, &quot;verde&quot;, rep(&quot;rojo&quot;, 4)) x ## [1] &quot;azul&quot; &quot;azul&quot; &quot;azul&quot; &quot;verde&quot; NA &quot;verde&quot; &quot;rojo&quot; &quot;rojo&quot; ## [9] &quot;rojo&quot; &quot;rojo&quot; moda &lt;- names(table(x))[which(table(x) == max(table(x)))] # Engorroso, no? x[is.na(x)] &lt;- moda x ## [1] &quot;azul&quot; &quot;azul&quot; &quot;azul&quot; &quot;verde&quot; &quot;rojo&quot; &quot;verde&quot; &quot;rojo&quot; &quot;rojo&quot; ## [9] &quot;rojo&quot; &quot;rojo&quot; # Puedo reemplazar partes de un vector x &lt;- 1:5 x[c(1, 2)] &lt;- 2:3 x ## [1] 2 3 3 4 5 # Las longitudes de las asignaciones tienen que ser iguales x[-1] &lt;- 4:1 x ## [1] 2 4 3 2 1 # No se revisan duplicados x[c(1, 1)] &lt;- 2:3 x ## [1] 3 4 3 2 1 # Puedo sustituir valores considerando toda la logica x &lt;- c(1:10) x[x &gt; 5] &lt;- 0 x ## [1] 1 2 3 4 5 0 0 0 0 0 Por último, es útil notar la utilidad de asignar utilizando la forma de asignar nada mencionada anteriormente. class(mtcars) ## [1] &quot;data.frame&quot; mtcars[] &lt;- lapply(mtcars, as.integer) class(mtcars) ## [1] &quot;data.frame&quot; dim(mtcars) ## [1] 32 11 mtcars &lt;- lapply(mtcars, as.integer) class(mtcars) ## [1] &quot;list&quot; dim(mtcars) ## NULL Asignar utilizando el operador de suconjunto a nada nos permite preservar la estructura del objeto original así como su clase. En el caso de listas, si combinamos un operador de subconjunto mas asignación a nulo, podemos remover objetos de ésta. x &lt;- list(a = 1, b = 2) x[[2]] &lt;- NULL str(x) ## List of 1 ## $ a: num 1 x[&quot;b&quot;] &lt;- list(NULL) str(x) ## List of 2 ## $ a: num 1 ## $ b: NULL 4.1.3 Operadores lógicos Ejemplo: Supongamos que queremos saber qué elementos de \\(x\\) son menores que \\(5\\) ó mayores que \\(8\\). x &lt;- c(1:10) x[(x&gt;8) | (x&lt;5)] ## [1] 1 2 3 4 9 10 # ¿Cómo funciona? x ## [1] 1 2 3 4 5 6 7 8 9 10 x &gt; 8 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE x &lt; 5 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE x &gt; 8 | x &lt; 5 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE # x &gt; 8 || x &lt; 5 x[c(T,T,T,T,F,F,F,F,T,T)] ## [1] 1 2 3 4 9 10 || vs. | y &amp;&amp; vs. &amp; La diferencia entre &amp; y &amp;&amp; (o | y ||) es que el primero es vectorizado y el segundo no. Ejercicio ¿Qué crees que pasa en las siguientes situaciones? rm(list = ls()) TRUE || a FALSE &amp;&amp; a TRUE &amp;&amp; a TRUE | a FALSE &amp; a La forma larga (la versión doble) no parece ser muy útil. El propósito de ésta es que es más apropiado cuando se programa usando estructuras de control, por ejemplo, en ifs*. if( c(T, F) ) print(&quot;Hola&quot;) ## [1] &quot;Hola&quot; Poner el &amp;&amp; me garantiza que la condicional será evaluado sobre un único valor falso/verdadero. (-2:2) &gt;= 0 ## [1] FALSE FALSE TRUE TRUE TRUE (-2:2) &lt;= 0 ## [1] TRUE TRUE TRUE FALSE FALSE ((-2:2) &gt;= 0) &amp;&amp; ((-2:2) &lt;= 0) ## [1] FALSE Ejercicio Explora los siguientes comandos impares &lt;- 1:10 %% 2 == 1 mult.3 &lt;- 1:10 %% 3 == 0 impares &amp; mult.3 impares | mult.3 xor(impares, mult.3) Bibliografía "],
["aplicaciones.html", "4.2 Aplicaciones", " 4.2 Aplicaciones Una de las formas más fáciles de frustrarse con R (y con cualquier otro lenguaje) es no saber decirle al lenguaje lo que se desea hacer. Entender cómo manipular las estructuras de datos y la lógica detrás de su comportamiento ahorra mucho sufrimiento y permite adaptarse ante cosas que necesitamos que aún no se encuentran implementadas por alguien más de una manera más sencilla. Con saber de subconjuntos podemos realizar varias tareas indispensables. 4.2.1 Buscarv o buscarh Excel es excelente haciendo estas tareas. Lo malo de excel es que no es reproducible. Es muy común que resulte imposible llegar de los datos originales al resultado final pues muchos pasos intermedios de limpieza no están documentados de forma alguna. Un script de limpieza nos permite no solamente ir del raw a la estructura de datos limpia y analizable sino que permite que alguien más verifique las operaciones que se están realizando, se identifiquen errores y que, cuando nos llega un nuevo mes, sea trivial incluir estos datos al resultado final. rm(list = ls()) x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;) busca &lt;- c(m = &quot;Male&quot;, f = &quot;Female&quot;, u = NA) busca[x] ## m f u f f m m ## &quot;Male&quot; &quot;Female&quot; NA &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; unname(busca[x]) ## [1] &quot;Male&quot; &quot;Female&quot; NA &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; c(m = &quot;humano&quot;, f = &quot;humano&quot;, u = &quot;desconocido&quot;)[x] ## m f u f f ## &quot;humano&quot; &quot;humano&quot; &quot;desconocido&quot; &quot;humano&quot; &quot;humano&quot; ## m m ## &quot;humano&quot; &quot;humano&quot; Esto nos permite pegar un vector a una base de datos de acuerdo a una condición. calificaciones &lt;- c(10, 9, 5, 5, 6) aprueba &lt;- data.frame( calificacion = 10:1, descripcion = c(rep(&quot;excelente&quot;, 2), &quot;bueno&quot;, rep(&quot;aceptable&quot;, 2) , rep(&quot;no satisfactorio&quot;, 5)), aprobatorio = c(rep(T, 5), rep(F, 5)) ) id &lt;- match(calificaciones, aprueba$calificacion) aprueba[id, ] ## calificacion descripcion aprobatorio ## 1 10 excelente TRUE ## 2 9 excelente TRUE ## 6 5 no satisfactorio FALSE ## 6.1 5 no satisfactorio FALSE ## 5 6 aceptable TRUE Ejercicios Realiza la misma operación con las calificaciones pero utilizando los nombres de las filas, es decir, los rownames(aprueba) Carga la libreria ggplot2 y utiliza la base de datos diamonds Utiliza el comando match para quedarte con las variables cut y x Genera la variable categórica tal que, si el precio es mayor que 5,000 el valor de price.cat es cara, si es mayor que 2,000 es normal y barata en otro caso. 4.2.2 Muestras aleatorias Podemos utilizar índices enteros para generar muestras aleatorias de nuestras bases de datos o de nuestros vectores. set.seed(102030) aprueba[sample(nrow(aprueba)), ] ## calificacion descripcion aprobatorio ## 10 1 no satisfactorio FALSE ## 2 9 excelente TRUE ## 8 3 no satisfactorio FALSE ## 7 4 no satisfactorio FALSE ## 9 2 no satisfactorio FALSE ## 3 8 bueno TRUE ## 1 10 excelente TRUE ## 6 5 no satisfactorio FALSE ## 4 7 aceptable TRUE ## 5 6 aceptable TRUE aprueba[sample(nrow(aprueba), replace = T, size = 5), ] ## calificacion descripcion aprobatorio ## 4 7 aceptable TRUE ## 1 10 excelente TRUE ## 4.1 7 aceptable TRUE ## 7 4 no satisfactorio FALSE ## 2 9 excelente TRUE Ejercicios Utiliza la base de datos de iris y genera un conjunto de prueba y uno de entrenamiento correspondientes al 20 y 80 % de los datos, respectivamente. Genera un vector x de tamaño 1000 con realizaciones de una normal media 10, varianza 3. Crea 100 muestras bootstrap del vector x. Calcula la media para cada una de tus muestras. Grafica con la función hist() el vector de medias de tus muestras. Genera un vector l de letras, tamaño 10 y ordénalo. (Usa letters y order). Ordena la base cars de acuerdo a distancia, en forma descendiente (muestra la cola -usa tail- de la base ordenada). 4.2.3 Expande bases Ahora, a veces tenemos tablas de resumen pero quisieramos extraer los datos originales. Combinamos rep con subconjuntos de enteros para expandir. df &lt;- data.frame( color = c(&quot;azul&quot;, &quot;verde&quot;, &quot;amarillo&quot;), n = c(4, 3, 5) ) df ## color n ## 1 azul 4 ## 2 verde 3 ## 3 amarillo 5 df[rep(1:nrow(df), df$n), ] ## color n ## 1 azul 4 ## 1.1 azul 4 ## 1.2 azul 4 ## 1.3 azul 4 ## 2 verde 3 ## 2.1 verde 3 ## 2.2 verde 3 ## 3 amarillo 5 ## 3.1 amarillo 5 ## 3.2 amarillo 5 ## 3.3 amarillo 5 ## 3.4 amarillo 5 4.2.4 Which, intersect y union Ya estuvimos utilizando otras aplicaciones de estos comandos: ordenamientos, selección de filas o columnas según una condición lógica. También utilizamos un comando muy útil llamado which. set.seed(45) x &lt;- sample(letters, 10) x &lt;= &quot;e&quot; ## [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE TRUE which(x &lt;= &quot;e&quot;) ## [1] 7 9 10 Junto con which, puedes usar intersect y union. pares &lt;- 1:10 %% 2 == 0 m.5 &lt;- 1:10 %% 5 == 0 c(1:10)[union(which(pares), which(m.5))] c(1:10)[intersect(which(pares), which(m.5))] c(1:10)[which(xor(pares, m.5))] 4.2.5 Generación de datos a partir de distribuciones R básico provee funciones de distribución de probabilidad (p), funciones de densidad (d), funciones cuantiles (q) y generación de números aleatorios (r) para varias distribuciones como la binomial, chi-cuadrada, gamma, geométrica, etc. Dutang (2016) resumen otros paquetes en donde se encuentran implementadas otras funcionalidades o distribuciones multivariadas y cópulas. En las funciones de R básico, podemos construir un dataframe con realizaciones de distintas distintas distribuciones, por ejemplo, a continuación generamos la variable \\(x\\) como realizaciones de una normal, \\(y\\) con realizaciones de una exponencial y \\(z\\) con realizaciones de una uniforme. df &lt;- data.frame( x = rnorm(100) , y = rexp(100) , z = runif(100) ) Bibliografía "],
["split-apply-combine.html", "4.3 Split-apply-combine", " 4.3 Split-apply-combine Muchos problemas en el análisis de datos pueden ser resueltos aplicando la estrategia separa, aplica y combina (SAC) en donde divides un problema en pequeños pedazos manejables, operas en forma independiente cada uno de éstos y después combinas los resultados obtenidos (Wickham 2011). Esta estrategia se utiliza en diversas etapas del análisis de datos, por ejemplo (Wickham 2011): Preparación de datos. Cuando se crean nuevas variables según grupos, cuando se realizan ordenamientos por grupos, cuando se estandariza o normaliza variables. Estadística descriptiva. Cuando se crean agregados por grupos como sus medias o medianas. Modelado. Cuando se calculan modelos separados para cada panel en un estudio de este tipo. Estos modelos pueden examinarse por separado o unificarse para construir modelos más sofisticados que los conjuguen. Esta estrategia se utiliza en muchas herramientas: en las tablas dinámicas de Microsoft Excel, el operador group by de SQL, el argumento by disponible en algunos procedimientos de SAS (Wickham 2011). El paradigma split-apply-combine se resume en la figura 4.1. Figura 4.1: Ejemplificación del split-apply-combine (Vaidyanathan 2014, Split-Apply-Combine) Replicamos los vectores \\(x\\) y \\(y\\) de la figura en un dataframe: letras &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) df &lt;- data.frame( x = sort(letras[rep(seq(letras), 2)]), y = c(2, 4, 0, 5, 5, 10) ) df ## x y ## 1 a 2 ## 2 a 4 ## 3 b 0 ## 4 b 5 ## 5 c 5 ## 6 c 10 Queremos estimar la media de los valores en el vector \\(y\\) para cada tipo de letra en el vector \\(x\\). Esto lo podemos hacer utilizando la estrategia SAC, como en la figura. # Dividimos for (l in unique(df$x) ){ print(paste0(&quot;Grupo con letra: &quot;, l)) print(df[l == df$x, ]) } ## [1] &quot;Grupo con letra: a&quot; ## x y ## 1 a 2 ## 2 a 4 ## [1] &quot;Grupo con letra: b&quot; ## x y ## 3 b 0 ## 4 b 5 ## [1] &quot;Grupo con letra: c&quot; ## x y ## 5 c 5 ## 6 c 10 # Aplicamos for (l in unique(df$x) ){ print(paste0(&quot;Media para valores de letra: &quot;, l)) print(mean(df[l == df$x, ]$y)) } ## [1] &quot;Media para valores de letra: a&quot; ## [1] 3 ## [1] &quot;Media para valores de letra: b&quot; ## [1] 2.5 ## [1] &quot;Media para valores de letra: c&quot; ## [1] 7.5 # Combinamos medias &lt;- list() for (l in unique(df$x) ){ medias[[l]] &lt;- mean(df[l == df$x, ]$y) } as.data.frame(list(letras = names(medias), medias = unname(unlist(medias)))) ## letras medias ## 1 a 3.0 ## 2 b 2.5 ## 3 c 7.5 R tiene muchas funciones que facilitan realizar este tipo de operaciones. En particular, la familia apply fue pensada para realizarlas. Cada una de las funciones en esta familia recibe una estructura de datos en particular, aplica de determinada manera la función que se le especifica y combina los resultados de una forma específica. 4.3.1 apply apply aplica una función a cada fila o columna en una matriz. Separa: por columna o fila según se especifica en el parámetro MARGIN (1 para filas, 2 para columnas). Aplica: la función que se especifica en el parámetro FUN. Combina: regresa un vector con los resultados. m &lt;- matrix(c(1:5, 6:10), nrow = 5, ncol = 2) # 1 is the row index 2 is the column index m ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 apply(m, 1, sum) ## [1] 7 9 11 13 15 apply(m, 2, sum) ## [1] 15 40 Ejercicio Haz una función que reciba un vector y devuelva la suma de la posición \\(v_i + v_{i + 1}\\). Para el n-esimo elemento, suma el primero. Aplica esa función a las columnas y filas de la matriz m. # Respuesta suma.rec &lt;- function(v){ resultado &lt;- c() for (e in seq(length(v) - 1)){ resultado[e] &lt;- v[e] + v[e + 1] } resultado[length(v)] &lt;- v[length(v)] + v[1] return(resultado) } m apply(m, 1, suma.rec) apply(m, 2, suma.rec) 4.3.2 lapply lapply aplica una función a cada elemento en una lista. Como sabemos, un data.frame es únicamente un estilo particular de lista tal que todos sus elementos tienen el mismo tamaño. Por ende, también podemos utilizar lapply para iterar sobre las columnas de un data.frame. lista &lt;- list(a = 1:10, b = 2:20) lapply(lista, mean) ## $a ## [1] 5.5 ## ## $b ## [1] 11 df &lt;- data.frame(a = 1:10, b = 11:20) lapply(df, mean) ## $a ## [1] 5.5 ## ## $b ## [1] 15.5 Ejercicio El summary de un data.frame genera un resumen para los vectores que la conforman de acuerdo a la clase de la misma. Genera una función que regrese una tabla de frecuencias para factores y caracteres o una lista con media, desviación estándar para vectores numéricos o enteros. Aplícalo a la base diamonds usando lapply. # Respuesta mi.resumen &lt;- function(vector){ if( class(vector) == &quot;factor&quot; || class(vector) == &quot;character&quot;){ table(vector) } else if ( class(vector) == &quot;numeric&quot; || class(vector) == &quot;integer&quot;) { list(media = mean(vector), de = sqrt(var(vector))) } } lapply(names(diamonds), FUN = function(c) mi.resumen(diamonds[, c])) 4.3.3 sapply sapply es otra versión de lapply que regresa una lista o un vector, dependiendo si se especifica el parámetro simplify = T y si la función aplicada regresa un único valor. x &lt;- sapply(lista, mean, simplify = F) x ## $a ## [1] 5.5 ## ## $b ## [1] 11 x &lt;- sapply(lista, mean, simplify = T) x ## a b ## 5.5 11.0 Ejercicio Obtén un vector tipo caracter con los nombres de las clases de las columnas de iris. # Respuesta sapply(iris, class) Ejercicio Repite el ejercicio de la suma rara pero usa sapply. Recuerda la instrucción: Haz una función que reciba un vector y devuelva la suma de la posición \\(v_i + v_{i + 1}\\). Para el n-esimo elemento, suma el primero. Utiliza sapply para realizar esta operacion. # Respuesta x &lt;- 1:10 sapply(seq(x), FUN = function(i){ if( i == length(x) ){ x[1] + x[i] } else { x[i] + x[i + 1] } }) 4.3.4 mapply mapply es como la versión multivariada de sapply. Le aplica una función a todos los elementos correspondientes de un argumento. l1 &lt;-list(a = c(1:5), b = c(6:10)) l2 &lt;- list(c = c(11:15), d = c(16:20)) l1 ## $a ## [1] 1 2 3 4 5 ## ## $b ## [1] 6 7 8 9 10 l2 ## $c ## [1] 11 12 13 14 15 ## ## $d ## [1] 16 17 18 19 20 mapply(sum, l1$a, l1$b, l2$c, l2$d) ## [1] 34 38 42 46 50 l1[[&quot;a&quot;]][1] + l1[[&quot;b&quot;]][1] + l2[[&quot;c&quot;]][1] + l2[[&quot;d&quot;]][1] ## [1] 34 Ejercicio Crea una matriz de 4 x 4 donde el primer renglón sea de unos, el segundo de dos, el tercero de 3 y el cuarto de 4. Usa mapply para hacerlo. # Respuesta m &lt;- matrix(c(rep(1, 4), rep(2, 4), rep(3, 4), rep(4, 4)), nrow = 4, byrow = T) m me &lt;- t(mapply(rep, 1:4, 4)) me 4.3.5 tapply tapply le aplica una función a subconjuntos de un vector. head(warpbreaks) ## breaks wool tension ## 1 26 A L ## 2 30 A L ## 3 54 A L ## 4 25 A L ## 5 70 A L ## 6 52 A L with(warpbreaks, tapply(breaks, list(wool, tension), mean)) ## L M H ## A 44.55556 24.00000 24.55556 ## B 28.22222 28.77778 18.77778 tapply(warpbreaks$breaks, list(wool = warpbreaks$wool, tension = warpbreaks$tension), mean) ## tension ## wool L M H ## A 44.55556 24.00000 24.55556 ## B 28.22222 28.77778 18.77778 Ejercicio Utiliza la función tapply y la base de datos diamonds (que está dentro del paquete ggplot2) para obtener las medias de la variable carat para los grupos formados por la variable categórica cut y la variable categórica color. # Respuesta library(ggplot2) with(diamonds, tapply(carat, list(cut, color), mean)) 4.3.6 by by le aplica una función a subconjuntos de un data.frame. Se divide un data.frame según los valores de de uno o más factores. Se aplica la función FUN a cada subconjunto. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa by(data = iris[, 1:2], INDICES = iris[, &quot;Species&quot;], FUN = summary) ## iris[, &quot;Species&quot;]: setosa ## Sepal.Length Sepal.Width ## Min. :4.300 Min. :2.300 ## 1st Qu.:4.800 1st Qu.:3.200 ## Median :5.000 Median :3.400 ## Mean :5.006 Mean :3.428 ## 3rd Qu.:5.200 3rd Qu.:3.675 ## Max. :5.800 Max. :4.400 ## -------------------------------------------------------- ## iris[, &quot;Species&quot;]: versicolor ## Sepal.Length Sepal.Width ## Min. :4.900 Min. :2.000 ## 1st Qu.:5.600 1st Qu.:2.525 ## Median :5.900 Median :2.800 ## Mean :5.936 Mean :2.770 ## 3rd Qu.:6.300 3rd Qu.:3.000 ## Max. :7.000 Max. :3.400 ## -------------------------------------------------------- ## iris[, &quot;Species&quot;]: virginica ## Sepal.Length Sepal.Width ## Min. :4.900 Min. :2.200 ## 1st Qu.:6.225 1st Qu.:2.800 ## Median :6.500 Median :3.000 ## Mean :6.588 Mean :2.974 ## 3rd Qu.:6.900 3rd Qu.:3.175 ## Max. :7.900 Max. :3.800 Puedo calcular, por ejemplo, la suma de los valores del largo y ancho de los sépalos en la base de datos iris según la especie. res &lt;- by(iris[, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)], iris[, &quot;Species&quot;], sum) Posteriormente, se pueden combinar los elementos. as.data.frame(list( &quot;species&quot; = names(res), &quot;suma&quot; = sapply(seq(length(res)), FUN = function(i) res[[i]]) )) ## species suma ## 1 setosa 421.7 ## 2 versicolor 435.3 ## 3 virginica 478.1 Ejercicio Vuelve a utilizar la base de diamonds para calcular el promedio de carat según cut y color. # Respuesta library(ggplot2) head(diamonds) res &lt;- by(diamonds[, c(&quot;carat&quot;)], list(cut = as.factor(diamonds$cut) , color = as.factor(diamonds$color)) , mean, simplify = T) 4.3.7 replicate replicate es una función muy útil sobretodo en el contexto de simulación. replicate(5, rnorm(5), simplify = F) ## [[1]] ## [1] -0.01744899 -0.35920817 -1.46121725 -0.82974515 0.53160175 ## ## [[2]] ## [1] -0.2601847 0.5065636 1.3330763 -1.4945952 0.8039902 ## ## [[3]] ## [1] -0.2155771 -0.8922644 -0.1466588 -0.3234650 -1.0602366 ## ## [[4]] ## [1] -1.4859165 1.4469633 1.5193526 1.4491572 0.3427115 ## ## [[5]] ## [1] -0.94652506 -1.25920627 -0.06813108 -0.75359982 0.43192663 replicate(6, rnorm(4), simplify = T) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 0.12276245 0.4528315 -0.1228450 -1.5292287 -0.42799037 0.6360040 ## [2,] 0.00389876 -0.4863693 -2.4085836 -0.7545786 1.92098812 0.3017047 ## [3,] -0.80426655 0.1570096 0.1789978 1.6316763 0.03015651 1.4364364 ## [4,] 0.12613563 -0.4231777 -0.7788772 0.6512902 -0.21573077 -0.7753874 hist(replicate(100, mean(rexp(10)))) Ejercicio Replica el ejercicio de muestras bootstrap utilizando la función replicate. Recordando las instrucciones: Genera un vector x de tamaño \\(1000\\) con realizaciones de una normal media \\(10\\), varianza \\(3\\). Crea \\(100\\) muestras bootstrap del vector \\(x\\). Calcula la media para cada una de tus muestras. Grafica con la función hist() el vector de medias de tus muestras. # Respuesta # 1 x &lt;- rnorm(1000, mean = 10, sd = sqrt(3)) hist( # 4 replicate(100, # 2 mean(sample(x, size = 1000, replace = T))), # 3 main = &quot;Muestras bootstrap&quot;, xlab = &quot;media&quot;, ylab = &quot;frecuencia&quot; ) 4.3.8 ¿Puede ser más fácil? La familia apply viene con R básico. Sin embargo, hay 3 implementaciones excelentes del paradigma split-apply-combine: plyr, dplyr y data.table. Si la familia apply es poderosa, se queda corta comparada con estos tres. plyr es la primera versión de SAC de Wickham (Wickham 2011). Posteriormente, mejoró muchas de las funciones en dplyr (Wickham and Francois, n.d.) sobretodo entorno a velocidad y facilidad de uso. plyr no termina de ser relevante pues varias de sus funciones aun no están en dplyr pero está por ser sustituido. data.table (Dowle et al. 2015), es una implementación con una tradición muy diferente y tiene también funciones muy poderosas aunque con una sintaxis muy distinta a dplyr. Es absurdamente eficiente y tiene múltiples aplicaciones. Muchas de las funciones en dplyr también están implementadas en data.table. Ambos paquetes son útiles pero priorizan distintos elementos. En el capítulo siguiente se repasarán los verbos en dplyr. Bibliografía "],
["material-adicional-2.html", "4.4 Material adicional", " 4.4 Material adicional Curso de swirl R Programming, módulos 10 a 15. Curso Intermediate R de Data Camp. Curso Intermediate R - Practice de Data Camp. "],
["herramientas-basicas-para-un-proyecto-de-datos.html", "Capítulo 5 Herramientas básicas para un proyecto de datos", " Capítulo 5 Herramientas básicas para un proyecto de datos Hola "],
["r-markdown.html", "5.1 R Markdown", " 5.1 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: "],
["conclusion.html", "Capítulo 6 Conclusión", " Capítulo 6 Conclusión Hola "],
["markdown.html", "A Markdown", " A Markdown Hola "],
["r-markdown-1.html", "A.1 R Markdown", " A.1 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: "],
["packrat.html", "B Packrat", " B Packrat Hola "],
["el-directorio-del-proyecto.html", "B.1 El directorio del proyecto", " B.1 El directorio del proyecto Directorio "],
["instalacion-1.html", "B.2 Instalación", " B.2 Instalación Instalación "],
["r-markdown-2.html", "B.3 R Markdown", " B.3 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: "],
["formatos.html", "C Formatos", " C Formatos Usa la mnemotécnica del inglés: get working directory ≡ getwd. Notarás como muchas funciones tienen un nombre que acorta lo que hacen. Packrat Cuando cambian las versiones de distintos paquetes de R, es posible que código que solía funcionar deje de hacerlo. Por esta razón, es conveniente empaquetar proyectos de código de manera que el código en un proyecto específico tenga asociados también las versiones específicas de los paquetes con los cuáles fue creado. Una forma de lograr esto es utilizando packrat. Para mayor detalle, ver el apéndice B. Ejercicios primero luego después En R Todo lo que existe es un objeto. Todo lo que sucede es una llamada a una función. Note Caution Important Tip Warning "],
["bibliografia.html", "Bibliografía", " Bibliografía "]
]
